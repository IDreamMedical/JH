<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0062)http://msdn.microsoft.com/en-US/library/ms379572(v=VS.80).aspx -->
<HTML xmlns="http://www.w3.org/1999/xhtml"><HEAD><TITLE>Part 3: Binary Trees and BSTs</TITLE><LINK 
href="http://msdn.microsoft.com/en-us/library/ms379572(v=vs.80).aspx" 
rel=canonical><LINK 
href="Part 3 Binary Trees and BSTs.files/024d86ac3c0dde3e6a230199128bdfe4.css" 
type=text/css rel=stylesheet><LINK media=print 
href="http://msdn.microsoft.com/en-US/library/ms379572(d=printer,v=VS.80).aspx" 
rel=alternate>
<META http-equiv=content-type content="text/html; charset=utf-8">
<META content=/en-us/library/ms379572(d=lightweight,l=en-us,v=VS.80).aspx 
name=DCS.dcsuri>
<META 
content=http://msdn.microsoft.com/en-us/library/ms379572(d=lightweight,l=en-us,v=VS.80).aspx 
name=NormalizedUrl>
<META 
content=http://msdn.microsoft.com/en-us/library/ms379572(l=en-us,v=VS.80).aspx 
name=VotingContextUrl>
<META content="C0384794-11:20:18 AM" name=MN>
<META content=ms379572 name=Search.ShortId>
<META content=en-us name=Ms.Locale>
<META content="MSHTML 6.00.2900.6049" name=GENERATOR></HEAD>
<BODY>
<DIV class=header>
<TABLE class="headerBar cl_lightweight_topnav_slice" cellSpacing=0 cellPadding=0 
border=0>
  <TBODY>
  <TR>
    <TD 
    class="leftSection cl_lightweight_header_leftSection_wave leftSectionImageClusterOverride">
      <DIV class=tabContainer><A class=" headerTab" title=Home 
      href="http://msdn.microsoft.com/en-US/">Home</A> <A 
      class="headerTabSelected cl_lightweight_selected_tab_repeatX " 
      title=Library href="http://msdn.microsoft.com/en-US/library">Library</A> 
      <A class=" headerTab" title=Learn 
      href="http://msdn.microsoft.com/en-US/bb188199.aspx">Learn</A> <A 
      class=" headerTab" title=Downloads 
      href="http://msdn.microsoft.com/en-US/aa570309.aspx">Downloads</A> <A 
      class=" headerTab" title=Support 
      href="http://msdn.microsoft.com/en-US/aa570318.aspx">Support</A> <A 
      class=" headerTab" title=Community 
      href="http://msdn.microsoft.com/en-US/aa497440.aspx">Community</A> 
    </DIV></TD>
    <TD 
    class="rightSection cl_lightweight_header_rightSection_wave rightSectionImageClusterOverride">
      <DIV class=tabContainer><A title="Sign in" 
      href="https://login.live.com/login.srf?wa=wsignin1.0&amp;rpsnv=11&amp;ct=1303496418&amp;rver=6.0.5276.0&amp;wp=MCLBI&amp;wlcxt=msdn%24msdn%24msdn&amp;wreply=http:%2F%2Fmsdn.microsoft.com%2Fen-US%2Flibrary%2Fms379572%2528v%3DVS.80%2529.aspx&amp;lc=1033&amp;cb=&amp;id=254354">Sign 
      in </A><SPAN class=pipe>|</SPAN> <A title=中国（简体中文） 
      href="http://msdn.microsoft.com/en-US/library/preferences/locale/?returnurl=%252fen-US%252flibrary%252fms379572(v%253dVS.80).aspx">中国（简体中文） 
      </A><SPAN class=pipe>|</SPAN> <A title=Preferences 
      href="http://msdn.microsoft.com/en-US/library/preferences/experience/?returnurl=%252fen-US%252flibrary%252fms379572(v%253dVS.80).aspx">Preferences</A> 
      </DIV></TD></TR></TBODY></TABLE></DIV>
<DIV class=contentPlaceHolder>
<DIV class=navigation id=Navigation style="PADDING-BOTTOM: 96px; WIDTH: 280px">
<DIV class=searchcontainer>
<FORM id=SearchForm 
style="PADDING-RIGHT: 0px; PADDING-LEFT: 0px; PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-TOP: 0px" 
action=http://social.msdn.microsoft.com/Search/en-US method=get>
<DIV class=searchBoxContainer>
<TABLE class=searchBox cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD class=searchTextBoxTd><INPUT class=searchTextBox id=searchTextBox 
      onblur="document.onkeydown = Presskey;WatermarkBlur(this, 'Search MSDN with Bing', 'searchTextBox')" 
      onfocus="document.onkeydown = ''; WatermarkFocus(this, 'Search MSDN with Bing', 'searchTextBoxTrue') " 
      maxLength=200 value="Search MSDN with Bing" name=query> </TD>
    <TD class=searchButtonTd><A 
      style="PADDING-RIGHT: 0px; DISPLAY: block; PADDING-LEFT: 0px; PADDING-BOTTOM: 0px; MARGIN: 0px; OVERFLOW: hidden; WIDTH: 19px; PADDING-TOP: 0px; POSITION: relative; HEIGHT: 19px" 
      onclick="javascript:if(document.getElementById('searchTextBox').value == 'Search MSDN with Bing')document.getElementById('searchTextBox').value=''; document.getElementById('SearchForm').submit();" 
      href="javascript:void(0)"><IMG class=cl_search_icon title=Search 
      style="POSITION: relative" alt=Search 
      src="Part 3 Binary Trees and BSTs.files/a19e30a4020fe81d2b1209058013a360.png"></A> 
    </TD></TR></TBODY></TABLE></DIV></FORM></DIV>
<DIV class=navcontainer>
<DIV class=nav>
<DIV class="toclevel0 ancestry">
<DIV class="clip5x9 nav_root"><IMG class=cl_nav_bullet alt="" 
src="Part 3 Binary Trees and BSTs.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class=nav_div_currentroot><A title="MSDN Library" 
href="http://msdn.microsoft.com/en-us/library/ms123401.aspx">MSDN 
Library</A></DIV>
<DIV class="clip5x9 nav_arrows"><IMG class=cl_nav_arrow alt="" 
src="Part 3 Binary Trees and BSTs.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class=nav_div_currentroot><A title="Development Tools and Languages" 
href="http://msdn.microsoft.com/en-us/library/aa187916.aspx">Development Tools 
and Languages</A></DIV>
<DIV class="clip5x9 nav_arrows"><IMG class=cl_nav_arrow alt="" 
src="Part 3 Binary Trees and BSTs.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class=nav_div_currentroot><A title="Visual Studio 2005" 
href="http://msdn.microsoft.com/en-us/library/ms950416.aspx">Visual Studio 
2005</A></DIV>
<DIV class="clip5x9 nav_arrows"><IMG class=cl_nav_arrow alt="" 
src="Part 3 Binary Trees and BSTs.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class=nav_div_currentroot><A title="Technical Articles" 
href="http://msdn.microsoft.com/en-us/library/aa468085.aspx">Technical 
Articles</A></DIV>
<DIV class="clip5x9 nav_arrows"><IMG class=cl_nav_arrow alt="" 
src="Part 3 Binary Trees and BSTs.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class=nav_div_currentroot><A title=C# 
href="http://msdn.microsoft.com/en-us/library/ms391942(v=VS.80).aspx">C#</A></DIV>
<DIV class="clip5x9 nav_arrows"><IMG class=cl_nav_arrow alt="" 
src="Part 3 Binary Trees and BSTs.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class=nav_div_currentroot><A 
title="An Extensive Examination of Data Structures Using C# 2.0" 
href="http://msdn.microsoft.com/en-us/library/ms364091(v=VS.80).aspx">An 
Extensive Examination of Data Structures Using C# 2.0</A></DIV></DIV>
<DIV class="clip13x9 nav_dots_current"><IMG class=cl_nav_dots alt="" 
src="Part 3 Binary Trees and BSTs.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class="toclevel1 current"><A title="Part 3: Binary Trees and BSTs" 
href="http://msdn.microsoft.com/en-us/library/ms379572(v=VS.80).aspx">Part 3: 
Binary Trees and BSTs</A></DIV>
<DIV class="toclevel2 children" 
style="BORDER-BOTTOM: #bbbbbb 1px solid"></DIV><IMG 
class="communityContentNavigationSeparator cl_lt_cc_line_top" alt=Separator 
src="Part 3 Binary Trees and BSTs.files/030c41d9079671d09a62d8e2c1db6973.gif"> 
</DIV></DIV></DIV><A class=tocResize id=TocResize style="LEFT: 280px" 
onclick=onIncreaseToc() 
href="http://msdn.microsoft.com/en-US/library/ms379572(v=VS.80).aspx#"><IMG 
class=cl_nav_resize_open onmousedown=onIncreaseToc() id=ResizeImageIncrease 
title=Expand alt=Expand 
src="Part 3 Binary Trees and BSTs.files/a19e30a4020fe81d2b1209058013a360.png"> 
<IMG class=cl_nav_resize_close onmousedown=onResetToc() id=ResizeImageReset 
title=Minimize style="DISPLAY: none" alt=Minimize 
src="Part 3 Binary Trees and BSTs.files/a19e30a4020fe81d2b1209058013a360.png"> 
</A>
<DIV class=content><IMG class="TOC_Fade_Top cl_lw_toc_fade_top" alt="" 
src="Part 3 Binary Trees and BSTs.files/030c41d9079671d09a62d8e2c1db6973.gif"> 
<DIV class="clip117x31 logo"><A 
href="http://msdn.microsoft.com/en-US/default.aspx"><IMG class=msdn_body_logo 
title=MSDN alt=MSDN 
src="Part 3 Binary Trees and BSTs.files/a19e30a4020fe81d2b1209058013a360.png"> 
</A></DIV>
<DIV class=topicContainer>
<DIV class=topic xmlns="http://www.w3.org/1999/xhtml" 
xmlns:mtps="http://msdn2.microsoft.com/mtps">
<H1 class=title>An Extensive Examination of Data Structures Using C# 2.0</H1>
<DIV class=lw_vs>
<DIV id=curversion><STRONG>Visual Studio 2005</STRONG> </DIV></DIV>
<DIV style="CLEAR: right"></DIV>
<DIV id=nstext valign="bottom">&nbsp; 
<P>Scott Mitchell<BR>4GuysFromRolla.com</P>
<P>Update January 2005</P>
<P><B>Summary: </B>This article, the third in a six-part series on data 
structures in the .NET Framework, looks at a common data structure that is 
<I>not</I> included in the .NET Framework Base Class Library—binary trees. 
Whereas arrays arrange data linearly, binary trees can be envisioned as storing 
data in two dimensions. A special kind of binary tree, called a binary search 
tree, or BST, allows for a much more optimized search time than with unsorted 
arrays. (30 printed pages)</P>
<FORM name=x>
<P><A 
href="http://download.microsoft.com/download/5/0/f/50f7b985-990b-4154-ac21-518bfe16f887/DataStructures20.msi">Download 
the DataStructures20.msi sample file</A>.</P>
<BLOCKQUOTE class=dtBlock><B>Editor's note&nbsp;&nbsp;&nbsp;</B>This six-part 
  article series originally appeared on MSDN Online starting in November 2003. 
  In January 2005 it was updated to take advantage of the new data structures 
  and features available with the .NET Framework version 2.0, and C# 2.0. The 
  original articles are still available at <A 
  href="http://msdn.microsoft.com/vcsharp/default.aspx?pull=/library/en-us/dv_vstechart/html/datastructures_guide.asp">http://msdn.microsoft.com/vcsharp/default.aspx?pull=/library/en-us/dv_vstechart/html/datastructures_guide.asp</A>. 
</BLOCKQUOTE>
<BLOCKQUOTE class=dtBlock><B>Note&nbsp;&nbsp;&nbsp;</B>This article assumes 
  the reader is familiar with C#.</BLOCKQUOTE>
<H4 class=dtH1>Contents</H4>
<P><A 
href="http://msdn.microsoft.com/en-US/library/ms379572(v=VS.80).aspx#datastructures20_3_topic1">Introduction</A><BR><A 
href="http://msdn.microsoft.com/en-US/library/ms379572(v=VS.80).aspx#datastructures20_3_topic2">Arranging 
Data in a Tree</A><BR><A 
href="http://msdn.microsoft.com/en-US/library/ms379572(v=VS.80).aspx#datastructures20_3_topic3">Understanding 
Binary Trees</A><BR><A 
href="http://msdn.microsoft.com/en-US/library/ms379572(v=VS.80).aspx#datastructures20_3_topic4">Improving 
the Search Time with Binary Search Trees (BSTs)</A><BR><A 
href="http://msdn.microsoft.com/en-US/library/ms379572(v=VS.80).aspx#datastructures20_3_topic5">Binary 
Search Trees in the Real-World</A></P>
<H2 class=dtH1><A name=datastructures20_3_topic1></A>Introduction</H2>
<P>In <SPAN class=unresolvedLink>Part 1</SPAN>, we looked at what data 
structures are, how their performance can be evaluated, and how these 
performance considerations play into choosing which data structure to utilize 
for a particular algorithm. In addition to reviewing the basics of data 
structures and their analysis, we also looked at the most commonly used data 
structure, the array, and its relative, the List. In <A 
href="http://msdn.microsoft.com/en-US/library/ms379571(v=VS.80).aspx">Part 2</A> 
we looked at the cousins of the List, the Stack and the Queue, which store their 
data like a List, but limit the means by which their contained data can be 
accessed. In Part 2 we also looked at the Hashtable and Dictionary classes, 
which are essentially arrays that are indexed by some arbitrary object as 
opposed to by an ordinal value.</P>
<P>The List, Stack, Queue, Hashtable, and Dictionary all use an underlying array 
as the means by which their data is stored. This means that, under the covers, 
these data structures are bound by the limitations imposed by an array. Recall 
from Part 1 that an array is stored linearly in memory, requires explicit 
resizing when the array's capacity is reached, and suffers from linear searching 
time.</P>
<P>In this third installment of the article series, we will examine a new data 
structure, the binary tree. As we'll see, binary trees store data in a 
non-linear fashion. After discussing the properties of binary trees, we'll look 
at a more specific type of binary tree—the binary search tree, or BST. A BST 
imposes certain rules on how the items of the tree are arranged. These rules 
provide BSTs with a sub-linear search time.</P>
<H2 class=dtH1><A name=datastructures20_3_topic2></A>Arranging Data in a 
Tree</H2>
<P>If you've ever looked at a genealogy table, or at the chain of command in a 
corporation, you've seen data arranged in a <I>tree</I>. A tree is composed of a 
collection of <I>nodes</I>, where each node has some associated data and a set 
of <I>children</I>. A node's children are those nodes that appear immediately 
beneath the node itself. A node's <I>parent</I> is the node immediately above 
it. A tree's <I>root</I> is the single node that contains no parent.</P>
<P>Figure 1 shows an example of the chain of command in a fictional company. 
</P>
<P class=fig><IMG alt="" src="Part 3 Binary Trees and BSTs.files/IC129400.gif" 
border=0></P>
<P class=label><B>Figure 1. Tree view of a chain of command in a fictitious 
company</B></P>
<P>In this example, the tree's root is Bob Smith, CEO. This node is the root 
because it has no parent. The Bob Smith node has one child, Tina Jones, 
President, whose parent is Bob Smith. The Tina Jones node has three 
children—Jisun Lee, CIO; Frank Mitchell, CFO; and Davis Johnson, VP of Sales. 
Each of these nodes' parent is the Tina Jones node. The Jisun Lee node has two 
children—Tony Yee and Sam Maher; the Frank Mitchell node has one child—Darren 
Kulton; and the Davis Johnson node has three children—Todd Brown, Jimmy Wong, 
and Sarah Yates.</P>
<P>All trees exhibit the following properties: </P>
<UL type=disc>
  <LI>There is precisely one root. 
  <LI>All nodes except the root have precisely one parent. 
  <LI>There are no <I>cycles</I>. That is, starting at any given node, there is 
  not some path that can take you back to the starting node. The first two 
  properties—that there exists one root and that all nodes save the root have 
  one parent—guarantee that no cycles exist. </LI></UL>
<P>Trees are useful for arranging data in a hierarchy. As we will discuss later 
in this article, the time to search for an item can be drastically reduced by 
intelligently arranging the hierarchy. Before we can arrive at that topic, 
though, we need to first discuss a special kind of tree, the <I>binary 
tree</I>.</P>
<BLOCKQUOTE class=dtBlock><B>Note&nbsp;&nbsp;&nbsp;</B>Throughout this article 
  we will be looking at numerous new terms and definitions. These definitions, 
  along with being introduced throughout the text, are listed in Appendix 
A.</BLOCKQUOTE>
<H2 class=dtH1><A name=datastructures20_3_topic3></A>Understanding Binary 
Trees</H2>
<P>A binary tree is a special kind of tree, one in which all nodes have at most 
two children. For a given node in a binary tree, the first child is referred to 
as the <I>left</I> child, while the second child is referred to as the 
<I>right</I> child. Figure 2 depicts two binary trees. </P>
<P class=fig><IMG alt="" src="Part 3 Binary Trees and BSTs.files/IC71494.gif" 
border=0></P>
<P class=label><B>Figure 2. Illustration of two binary trees</B></P>
<P>Binary tree (a) has 8 nodes, with node 1 as its root. Node 1's left child is 
node 2; node 1's right child is node 3. Notice that a node doesn't need to have 
both a left child and right child. In binary tree (a), node 4, for example, has 
only a right child. Furthermore, a node can have no children. In binary tree 
(b), nodes 4, 5, 6, and 7 all have no children.</P>
<P>Nodes that have no children are referred to as <I>leaf nodes</I>. Nodes that 
have one or two children are referred to as <I>internal nodes</I>. Using these 
new definitions, the leaf nodes in binary tree (a) are nodes 6 and 8; the 
internal nodes are nodes 1, 2, 3, 4, 5, and 7.</P>
<P>Unfortunately, the .NET Framework does not contain a binary tree class, so in 
order to better understand binary trees, let's take a moment to create our own 
binary tree class. </P>
<H3 class=dtH1>The First Step: Creating a Base Node Class</H3>
<P>The first step in designing our binary tree class is to create a class that 
represents the nodes of the binary tree. Rather than create a class specific to 
nodes in a binary tree, let's create a base <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Node</TT> class that can be extended 
to meet the needs of a binary tree node through inheritance. The base <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Node</TT> class represents a node in 
a general tree, one whose nodes can have an arbitrary number of children. To 
model this, we'll create not just a <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Node</TT> class, but a <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">NodeList</TT> class as well. The Node 
class contains some data and a NodeList instance, which represents the node's 
children. The <TT xmlns:asp="http://msdn2.microsoft.com/asp">Node</TT> class 
affords a perfect time to utilize the power of Generics, which will allow us to 
let the developer using the class decide at develop-time what type of data to 
store in the node. </P>
<P>The following is the code for the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Node</TT> class. </P><PRE class=code>public class Node&lt;T&gt;
{
        // Private member-variables
        private T data;
        private NodeList&lt;T&gt; neighbors = null;

        public Node() {}
        public Node(T data) : this(data, null) {}
        public Node(T data, NodeList&lt;T&gt; neighbors)
        {
            this.data = data;
            this.neighbors = neighbors;
        }

        public T Value
        {
            get
            {
                return data;
            }
            set
            {
                data = value;
            }
        }

        protected NodeList&lt;T&gt; Neighbors
        {
            get
            {
                return neighbors;
            }
            set
            {
                neighbors = value;
            }
        }
    }
}
</PRE>
<P>Note that the <TT xmlns:asp="http://msdn2.microsoft.com/asp">Node</TT> class 
has two private member variables: </P>
<UL type=disc>
  <LI><TT xmlns:asp="http://msdn2.microsoft.com/asp">data</TT>, of type <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">T</TT>. This member variable 
  contains the data stored in the node of the type specified by the developer 
  using this class. 
  <LI><TT xmlns:asp="http://msdn2.microsoft.com/asp">neighbors</TT>, of type <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">NodeList&lt;T&gt;</TT>. This member 
  variable represents the node's children. </LI></UL>
<P>The remainder of the class contains the constructors and the public 
properties, which provide access to the two member variables.</P>
<P>The <TT xmlns:asp="http://msdn2.microsoft.com/asp">NodeList</TT> class 
contains a strongly-typed collection of <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Node&lt;T&gt;</TT> instances. As the 
following code shows, the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">NodeList</TT> class is derived from 
the <TT xmlns:asp="http://msdn2.microsoft.com/asp">Collection&lt;T&gt;</TT> 
class in the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">System.Collections.Generics</TT> 
namespace. The <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Collection&lt;T&gt;</TT> class 
provides the base functionality for a strong-typed collection, with methods like 
<TT xmlns:asp="http://msdn2.microsoft.com/asp">Add(T)</TT>, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Remove(T)</TT>, and <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Clear()</TT>, and properties like <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Count</TT> and a default indexer. In 
addition to the methods and properties inherited from <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Collection&lt;T&gt;</TT>, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">NodeList</TT> provides a constructor 
that creates a specified number of nodes in the collection, and a method that 
searches the collection for an element of a particular value.</P><PRE class=code>public class NodeList&lt;T&gt; : Collection&lt;Node&lt;T&gt;&gt;
{
    public NodeList() : base() { }

    public NodeList(int initialSize)
    {
        // Add the specified number of items
        for (int i = 0; i &lt; initialSize; i++)
            base.Items.Add(default(Node&lt;T&gt;));
    }

    public Node&lt;T&gt; FindByValue(T value)
    {
        // search the list for the value
        foreach (Node&lt;T&gt; node in Items)
            if (node.Value.Equals(value))
                return node;

        // if we reached here, we didn't find a matching node
        return null;
    }
}
</PRE>
<BLOCKQUOTE class=dtBlock><B>Note&nbsp;&nbsp;&nbsp;</B>The impetus behind 
  creating a generic <B>Node</B> class is because later in this article, as well 
  as in future parts, we'll be creating other classes that are made up of a set 
  of nodes. Rather than have each class create its own specific node class, each 
  class will borrow the functionality of the base <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">Node</TT> class and extend the base 
  class to meet its particular needs.</BLOCKQUOTE>
<H3 class=dtH1>Extending the Base Node Class</H3>
<P>While the <TT xmlns:asp="http://msdn2.microsoft.com/asp">Node</TT> class is 
adequate for any generic tree, a binary tree has tighter restrictions. As 
discussed earlier, a binary tree's nodes have at most two children, commonly 
referred to as left and right. To provide a binary tree-specific node class, we 
can extend the base Node class by creating a <B>BinaryTreeNode</B> class that 
exposes two properties—<TT xmlns:asp="http://msdn2.microsoft.com/asp">Left</TT> 
and <TT xmlns:asp="http://msdn2.microsoft.com/asp">Right</TT>—that operate on 
the base class's <TT xmlns:asp="http://msdn2.microsoft.com/asp">Neighbors</TT> 
property.</P><PRE class=code>public class BinaryTreeNode&lt;T&gt; : Node&lt;T&gt;
{
    public BinaryTreeNode() : base() {}
    public BinaryTreeNode(T data) : base(data, null) {}
    public BinaryTreeNode(T data, BinaryTreeNode&lt;T&gt; left, BinaryTreeNode&lt;T&gt; right)
    {
        base.Value = data;
        NodeList&lt;T&gt; children = new NodeList&lt;T&gt;(2);
        children[0] = left;
        children[1] = right;

        base.Neighbors = children;
    }

    public BinaryTreeNode&lt;T&gt; Left
    {
        get
        {
            if (base.Neighbors == null)
                return null;
            else
                return (BinaryTreeNode&lt;T&gt;) base.Neighbors[0];
        }
        set
        {
            if (base.Neighbors == null)
                base.Neighbors = new NodeList&lt;T&gt;(2);

            base.Neighbors[0] = value;
        }
    }

    public BinaryTreeNode&lt;T&gt; Right
    {
        get
        {
            if (base.Neighbors == null)
                return null;
            else
                return (BinaryTreeNode&lt;T&gt;) base.Neighbors[1];
        }
        set
        {
            if (base.Neighbors == null)
                base.Neighbors = new NodeList&lt;T&gt;(2);

            base.Neighbors[1] = value;
        }
    }
}
</PRE>
<P>The lion's share of the work of this extended class is in the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Right</TT> and <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Left</TT> properties. In these 
properties we need to ensure that the base class's <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Neighbors</TT> <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">NodeList</TT> has been created. If it 
hasn't, then in the get accessor we return <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">null</TT>; in the set accessor we 
need to create a new <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">NodeList</TT> with precisely two 
elements. As you can see in the code, the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Left</TT> property refers to the 
first element in the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Neighbors</TT> collection (<TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Neighbors[0]</TT>), while <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Right</TT> refers to the second (<TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Neighbors[1]</TT>).</P>
<H3 class=dtH1>Creating the BinaryTree Class</H3>
<P>With the <TT xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTreeNode</TT> 
class complete, the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTree</TT> class is a cinch to 
develop. The <TT xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTree</TT> 
class contains a single private member variable—<TT 
xmlns:asp="http://msdn2.microsoft.com/asp">root</TT>. <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">root</TT> is of type <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTreeNode</TT> and represents 
the root of the binary tree. This private member variable is exposed as a public 
property. (The <TT xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTree</TT> 
class uses Generics as well; the type specified for the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTree</TT> class is the type 
used for the <TT xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTreeNode</TT> 
root.)</P>
<P>The <TT xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTree</TT> class has 
a single public method, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Clear()</TT>, which clears out the 
contents of the tree. <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Clear()</TT> works by simply setting 
the <TT xmlns:asp="http://msdn2.microsoft.com/asp">root</TT> to <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">null</TT>. Other than the root and a 
<TT xmlns:asp="http://msdn2.microsoft.com/asp">Clear()</TT> method, the 
<B>BinaryTree</B> class contains no other properties or methods. Crafting the 
contents of the binary tree is the responsibility of the developer using this 
data structure.</P>
<P>Below is the code for the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTree</TT> class.</P><PRE class=code>public class BinaryTree&lt;T&gt;
{
   private BinaryTreeNode&lt;T&gt; root;

   public BinaryTree()
   {
      root = null;
   }

   public virtual void Clear()
   {
      root = null;
   }

   public BinaryTreeNode&lt;T&gt; Root
   {
      get
      {
         return root;
      }
      set
      {
         root = value;
      }
   }
}
</PRE>
<P>The following code illustrates how to use the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTree</TT> class to generate a 
binary tree with the same data and structure as binary tree (a) shown in Figure 
2.</P><PRE class=code>BinaryTree&lt;int&gt; btree = new BinaryTree&lt;int&gt;();
btree.Root = new BinaryTreeNode&lt;int&gt;(1);
btree.Root.Left = new BinaryTreeNode&lt;int&gt;(2);
btree.Root.Right = new BinaryTreeNode&lt;int&gt;(3);

btree.Root.Left.Left = new BinaryTreeNode&lt;int&gt;(4);
btree.Root.Right.Right = new BinaryTreeNode&lt;int&gt;(5);

btree.Root.Left.Left.Right = new BinaryTreeNode&lt;int&gt;(6);
btree.Root.Right.Right.Right = new BinaryTreeNode&lt;int&gt;(7);

btree.Root.Right.Right.Right.Right = new BinaryTreeNode&lt;int&gt;(8);
</PRE>
<P>Note that we start by creating a <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTree</TT> class instance, and 
then create its root. We then must manually add new <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTreeNode</TT> class instances 
to the appropriate left and right children. For example, to add node 4, which is 
the left child of the left child of the root, we use: <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">btree.Root.Left.Left = new 
BinaryTreeNode&lt;int&gt;(4);</TT></P>
<P>Recall from Part 1 of this article series that an array's elements are stored 
in a contiguous block of memory. By doing so, arrays exhibit constant-time 
lookups. That is, the time it takes to access a particular element of an array 
does not change as the number of elements in the array increases.</P>
<P>Binary trees, however, are not stored contiguously in memory, as Figure 3 
illustrates. Rather, the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTree</TT> class instance has a 
reference to the root <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTreeNode</TT> class instance. 
The root <TT xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTreeNode</TT> 
class instance has references to its left and right child <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTreeNode</TT> instances; these 
child instances have references to their child instances, and so on. The point 
is, the various <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTreeNode</TT> instances that 
makeup a binary tree can be scattered throughout the CLR managed heap. They are 
not necessarily contiguous, as are the elements of an array.</P>
<P class=fig><IMG alt="" src="Part 3 Binary Trees and BSTs.files/IC87068.gif" 
border=0></P>
<P class=label><B>Figure 3. Binary trees stored in memory</B></P>
<P>Imagine that we wanted to access a particular node in a binary tree. To 
accomplish this we need to search the binary tree's set of nodes, looking for 
the particular node. There's no direct access to a given node as with an array. 
Searching a binary tree can take linear time, as potentially all nodes will need 
to be examined. That is, as the number of nodes in the binary tree increases, 
the number of steps to find an arbitrary node will increase as well.</P>
<P>So, if a binary tree's lookup time is linear, and its search time is linear, 
how is the binary tree any better than an array, whose search time is linear, 
but whose lookup time is constant? Well, a generic binary tree doesn't offer us 
any benefit over an array. However, by intelligently organizing the items in a 
binary tree, we can greatly improve the search time (and therefore the lookup 
time as well).</P>
<H2 class=dtH1><A name=datastructures20_3_topic4></A>Improving the Search Time 
with Binary Search Trees (BSTs)</H2>
<P>A <I>binary search tree</I> is a special kind of binary tree designed to 
improve the efficiency of searching through the contents of a binary tree. 
Binary search trees exhibit the following property: for any node <I>n</I>, every 
descendant node's value in the left <I>subtree</I> of <I>n</I> is less than the 
value of <I>n</I>, and every descendant node's value in the right <I>subtree</I> 
is greater than the value of <I>n</I>.</P>
<P>A subtree rooted at node <I>n</I> is the tree formed by imaging node <I>n</I> 
was a root. That is, the subtree's nodes are the descendants of <I>n</I> and the 
subtree's root is <I>n</I> itself. Figure 4 illustrates the concept of subtrees 
and the binary search tree property.</P>
<P class=fig><IMG alt="" src="Part 3 Binary Trees and BSTs.files/IC71651.gif" 
border=0></P>
<P class=label><B>Figure 4. Subtrees and the binary search tree property</B></P>
<P>Figure 5 shows two examples of binary trees. The one on the right, binary 
tree (b), is a BST because it exhibits the binary search tree property. Binary 
tree (a), however, is not a BST because not all nodes of the tree exhibit the 
binary search tree property. Namely, node 10's right child, 8, is less than 10 
but it appears in node 10's right subtree. Similarly, node 8's right child, node 
4, is less than 8 but appears on node 8's right subtree. This property is 
violated in other locations, too. For example, node 9's right subtree contains 
values less than 9, namely 8 and 4.</P>
<P class=fig><IMG alt="" src="Part 3 Binary Trees and BSTs.files/IC155647.gif" 
border=0></P>
<P class=label><B>Figure 5. Comparison of non-BST binary tree (a) and a BST 
binary tree (b)</B></P>
<P>Note that for the binary search tree property to be upheld, the data stored 
in the nodes of a BST must be able to be compared to one another. Specifically, 
given two nodes, a BST must be able to determine if one is less than, greater 
than, or equal to the other.</P>
<P>Now, imagine that you want to search a BST for a particular node. For 
example, for the BST in Figure 5 (the binary tree (b)), imagine that we wanted 
to search for the node 10. A BST, like a regular binary tree, only has a direct 
reference to one node, its root. Can you think of an optimal way to search the 
tree to see if node 10 exists? There's a better way than searching through each 
node in the tree.</P>
<P>To see if 10 exists in the tree we can start with the root. We see that the 
root's value (7) is less than the value of the node we are looking for. 
Therefore, if 10 does exist in the BST, it must be in the root's right subtree. 
Therefore, we continue our search at node 11. Here we notice that 10 is less 
than 11, so if 10 exists in the BST it must exist in the left subtree of 11. 
Moving onto the left child of 11, we find node 10, and have located the node we 
are looking for.</P>
<P>What happens if we search for a node that does not exist in the tree? Imagine 
that we wanted to find node 9. We'd start by repeating the same steps above. 
Upon reaching node 10, we'd see that node 10 was greater than 9, so 9, if it 
exists, must be in 10's left subtree. However, we'd notice that 10 has no left 
child, therefore 9 must not exist in the tree.</P>
<P>More formally, our searching algorithm goes as follows. We have a node 
<I>n</I> we wish to find (or determine if it exists), and we have a reference to 
the BST's root. This algorithm performs a number of comparisons until a null 
reference is hit or until the node we are searching for is found. At each step 
we are dealing with two nodes: a node in the tree, call it <I>c</I>, that we are 
currently comparing with <I>n</I>, the node we are looking for. Initially, 
<I>c</I> is the root of the BST. We apply the following steps: </P>
<OL type=1>
  <LI>If <I>c</I> is a null reference, then exit the algorithm. <I>n</I> is not 
  in the BST. 
  <LI>Compare <I>c</I>'s value and <I>n</I>'s value. 
  <LI>If the values are equal, then we found <I>n</I>. 
  <LI>If <I>n</I>'s value is less than <I>c</I>'s then <I>n</I>, if it exists, 
  must be in the <I>c</I>'s left subtree. Therefore, return to step 1, letting 
  <I>c</I> be <I>c</I>'s left child. 
  <LI>If <I>n</I>'s value is greater than <I>c</I>'s then <I>n</I>, if it 
  exists, must be in the <I>c</I>'s right subtree. Therefore, return to step 1, 
  letting <I>c</I> be <I>c</I>'s right child. </LI></OL>
<P>We applied these steps earlier when searching for node 10. We started with 
the root node and noted that 10 was greater than 7, so we repeated our 
comparison with the root's right child, 11. Here, we noted 10 was less than 11, 
so we repeated our comparison with 11's left child. At this point we had found 
node 10. When searching for node 9, which did not exist, we wound up performing 
our comparison with 10's left child, which was a null reference. Hence we 
deduced that 9 did not exist in the BST.</P>
<H3 class=dtH1>Analyzing the BST Search Algorithm</H3>
<P>For finding a node in a BST, at each stage we ideally reduce the number of 
nodes we have to check by half. For example, consider the BST in Figure 6, which 
contains 15 nodes. When starting our search algorithm at the root, our first 
comparison will take us to either the root's left or right child. In either 
case, once this step is made the number of nodes that need to be considered has 
just halved, from 15 down to 7. Similarly, at the next step the number is halved 
again, from 7 down to 3, and so on.</P>
<P class=fig><IMG alt="" src="Part 3 Binary Trees and BSTs.files/IC520.gif" 
border=0></P>
<P class=label><B>Figure 6. BST with 15 nodes</B></P>
<P>The important concept to understand here is that ideally at each step in the 
algorithm the number of nodes that have to be considered has been cut in half. 
Compare this to searching an array. When searching an array we have to search 
<I>all</I> elements, one element at a time. That is, when searching an array 
with <I>n</I> elements, after we check the first element, we still have <I>n</I> 
– 1 elements to check. With a BST of <I>n</I> nodes, however, after checking the 
root we have whittled the problem down to searching a BST with <I>n</I>/2 
nodes.</P>
<P>Searching a binary tree is similar in analysis to searching a sorted array. 
For example, imagine you wanted to find if there is a John King in the 
phonebook. You could start by flipping to the middle of the phone book. Here, 
you'd likely find people with last names starting with the letter M. Because K 
comes before M alphabetically, you would then flip halfway between the start of 
the phonebook and the page you had reached in the Ms. Here, you might end up in 
the Hs. Since K comes after H, you'd flip half way between the Hs and the Ms. 
This time you might hit the Ks, where you could quickly see if James King was 
listed.</P>
<P>This is similar to searching a BST. With an ideally arranged BST the midpoint 
is the root. We then traverse down the tree, navigating to the left and right 
children as needed. These approaches cut the search space in half at each step. 
Such algorithms that exhibit this property have an asymptotic running time of 
log<SUB>2</SUB><SUB> </SUB><I>n</I>, commonly abbreviated lg <I>n</I>. Recall 
from our mathematical discussions in Part 1 of this article series that 
log<SUB>2</SUB> <I>n</I> = <I>y</I> means that 2<SUP>y</SUP> = <I>n</I>. That 
is, as <I>n</I> grows, log<SUB>2</SUB> <I>n</I> grows very slowly. The growth 
rate of log<SUB>2</SUB> <I>n</I> compared to linear grown is shown in the graph 
in Figure 7. Due to log<SUB>2</SUB> <I>n</I>'s slower growth than linear time, 
algorithms that run in asymptotic time log<SUB>2</SUB> <I>n</I> are said to be 
sublinear.</P>
<P class=fig><IMG alt="" src="Part 3 Binary Trees and BSTs.files/IC142598.gif" 
border=0></P>
<P class=label><B>Figure 7. Comparison of linear growth rate vs. 
log</B><SUB>2</SUB><B> <I>n</I></B></P>
<P>While it may appear that the logarithmic curve is flat, it is increasing, 
albeit rather slowly. To appreciate the difference between linear and sublinear 
growth, consider searching an array with 1,000 elements versus searching a BST 
with 1,000 elements. For the array, we'll have to search up to 1,000 elements. 
For the BST, we'd ideally have to search no more than <I>ten</I> nodes! (Note 
that log<SUB>10</SUB> 1024 equals 10.)</P>
<P>Throughout our analysis of the BST search algorithm, I've repeatedly used the 
word "ideally." This is because the search time for a BST depends upon its 
<I>topology</I>, or how the nodes are laid out with respect to one another. For 
a binary tree like the one in Figure 6, each comparison stage in the search 
algorithm trims the search space in half. However, consider the BST shown in 
Figure 8, whose topology is synonymous to how an array is arranged.</P>
<P class=fig><IMG alt="" src="Part 3 Binary Trees and BSTs.files/IC108139.gif" 
border=0></P>
<P class=label><B>Figure 8. Example of BST that will be searched in linear 
time</B></P>
<P>Searching the BST in Figure 8 will take linear time because after each 
comparison the problem space is only reduced by 1 node, not by half of the 
current nodes, as with the BST in Figure 6.</P>
<P>Therefore, the time it takes to search a BST is dependent upon its topology. 
In the best case, the time is on the order of log<SUB>2</SUB><I> n</I>, but in 
the worst case it requires linear time. As we'll see in the next section, the 
topology of a BST is dependent upon the order with which the nodes are inserted. 
Therefore, the order with which the nodes are inserted affects the running time 
of the BST search algorithm.</P>
<H3 class=dtH1>Inserting Nodes into a BST</H3>
<P>We've seen how to search a BST to determine if a particular node exists, but 
we've yet to look at how to add a new node. When adding a new node we can't 
arbitrarily add the new node; rather, we have to add the new node such that the 
binary search tree property is maintained.</P>
<P>When inserting a new node we will always insert the new node as a leaf node. 
The only challenge, then, is finding the node in the BST which will become this 
new node's parent. Like with the searching algorithm, we'll be making 
comparisons between a node <I>c</I> and the node to be inserted, <I>n</I>. We'll 
also need to keep track of <I>c</I>'s parent node. Initially, <I>c</I> is the 
BST root and <I>parent</I> is a null reference. Locating the new parent node is 
accomplished by using the following algorithm: </P>
<OL type=1>
  <LI>If <I>c</I> is a null reference, then <I>parent</I> will be the parent of 
  <I>n</I>. If <I>n</I>'s value is less than <I>parent</I>'s value, then 
  <I>n</I> will be <I>parent</I>'s new left child; otherwise <I>n</I> will be 
  <I>parent</I>'s new right child. 
  <LI>Compare <I>c</I> and <I>n</I>'s values. 
  <LI>If <I>c</I>'s value equals <I>n</I>'s value, then the user is attempting 
  to insert a duplicate node. Either simply discard the new node, or raise an 
  exception. (Note that the nodes' values in a BST must be unique.) 
  <LI>If <I>n</I>'s value is less than <I>c</I>'s value, then <I>n</I> must end 
  up in <I>c</I>'s left subtree. Let <I>parent</I> equal <I>c</I> and <I>c</I> 
  equal <I>c</I>'s left child, and return to step 1. 
  <LI>If <I>n</I>'s value is greater than <I>c</I>'s value, then <I>n</I> must 
  end up in <I>c</I>'s right subtree. Let <I>parent</I> equal <I>c</I> and 
  <I>c</I> equal <I>c</I>'s right child, and return to step 1. </LI></OL>
<P>This algorithm terminates when the appropriate leaf is found, which attaches 
the new node to the BST by making the new node an appropriate child of 
<I>parent</I>. There's one special case you have to worry about with the insert 
algorithm: if the BST does not contain a root, then there <I>parent</I> will be 
null, so the step of adding the new node as a child of <I>parent</I> is 
bypassed; furthermore, in this case the BST's root must be assigned to the new 
node.</P>
<P>Figure 9 depicts the BST insert graphically. </P>
<P class=fig><IMG alt="" src="Part 3 Binary Trees and BSTs.files/IC64179.gif" 
border=0></P>
<P class=label><B>Figure 9. Insert into a BST</B></P>
<P>Both the BST search and insert algorithms share the same running 
time—log<SUB>2</SUB> <I>n</I> in the best case, and linear in the worst case. 
The insert algorithm's running time mimics the search's because it, essentially, 
uses the same tactics used by the search algorithm to find the location for the 
newly inserted node.</P>
<H4 class=dtH1>The Order of Insertion Determines the BST's Topology</H4>
<P>Since newly inserted nodes into a BST are inserted as leaves, the order of 
insertion directly affects the topology of the BST itself. For example, imagine 
we insert the following nodes into a BST: 1, 2, 3, 4, 5, and 6. When 1 is 
inserted, it is insert as the root. Next, 2 is inserted as 1's right child. 3 is 
inserted as 2's right child, 4 as 3's right child, and so on. The resulting BST 
is one whose structure is precisely that of the BST in Figure 8.</P>
<P>If the values 1, 2, 3, 4, 5, and 6 had been inserted in a more intelligent 
manner, the BST would have had more breadth, and would have looked more like the 
tree in Figure 6. The ideal insertion order would be: 4, 2, 5, 1, 3, 6. This 
would put 4 at the root, 2 as 4's left child, 5 as 4's right child, 1 and 3 as 
2's left and right children, and 6 as 5's right child.</P>
<P>Because the topology of a BST can greatly affect the running time of search, 
insert, and (as we will see in the next section) delete, inserting data in 
ascending or descending order (or in near order) can have devastating results on 
the efficiency of the BST. We'll discuss this topic in more detail at the 
article's end, in the "Binary Search Trees in the Real-World" section.</P>
<H3 class=dtH1>Deleting Nodes from a BST</H3>
<P>Deleting nodes from a BST is slightly more difficult than inserting a node 
because deleting a node that has children requires that some other node be 
chosen to replace the hole created by the deleted node. If the node to replace 
this hole is not chosen with care, the binary search tree property may be 
violated. For example, consider the BST in Figure 6. If the node 150 is deleted, 
some node must be moved to the hole created by node 150's deletion. If we 
arbitrarily choose to move, say node 92 there, the BST property is deleted since 
92's new left subtree will have nodes 95 and 111, both of which are greater than 
92 and thereby violating the binary search tree property.</P>
<P>The first step in the algorithm to delete a node is to first locate the node 
to delete. This can be done using the searching algorithm discussed earlier, and 
therefore has a log<SUB>2</SUB> <I>n</I> running time. Next, a node from the BST 
must be selected to take the deleted node's position. There are three cases to 
consider when choosing the replacement node, all of which are illustrated in 
Figure 10. </P>
<UL type=disc>
  <LI><B>Case 1:</B> If the node being deleted has no right child, then the 
  node's left child can be used as the replacement. The binary search tree 
  property is maintained because we know that the deleted node's left subtree 
  itself maintains the binary search tree property, and that the values in the 
  left subtree are all less than or all greater than the deleted node's parent, 
  depending on whether the deleted node is a left or right child. Therefore, 
  replacing the deleted node with its left subtree will maintain the binary 
  search tree property. 
  <LI><B>Case 2:</B> If the deleted node's right child has no left child, then 
  the deleted node's right child can replace the deleted node. The binary search 
  tree property is maintained because the deleted node's right child is greater 
  than all nodes in the deleted node's left subtree and is either greater than 
  or less than the deleted node's parent, depending on whether the deleted node 
  was a right or left child. Therefore, replacing the deleted node with its 
  right child will maintain the binary search tree property. 
  <LI><B>Case 3:</B> Finally, if the deleted node's right child does have a left 
  child, then the deleted node needs to be replaced by the deleted node's right 
  child's left-most descendant. That is, we replace the deleted node with the 
  deleted node's right subtree's <I>smallest</I> value. 
  <BLOCKQUOTE class=dtBlock><B>Note&nbsp;&nbsp;&nbsp;</B>Realize that for any 
    BST, the smallest value in the BST is the left-most node, while the largest 
    value is the right-most node.</BLOCKQUOTE>
  <P>This replacement choice maintains the binary search tree property because 
  it chooses the smallest node from the deleted node's right subtree, which is 
  guaranteed to be larger than all node's in the deleted node's left subtree. 
  Too, since it's the smallest node from the deleted node's right subtree, by 
  placing it at the deleted node's position, all of the nodes in its right 
  subtree will be greater. </P></LI></UL>
<P>Figure 10 illustrates the node to choose for replacement for each of the 
three cases.</P>
<P class=fig><IMG alt="" src="Part 3 Binary Trees and BSTs.files/IC92100.gif" 
border=0></P>
<P class=label><B>Figure 10. Cases to consider when deleting a node</B></P>
<P>As with the insert and searching algorithms, the asymptotic running time of 
delete is dependent upon the BST's topology. Ideally, the running time is on the 
order of log<SUB>2</SUB> <I>n</I>. However, in the worst case, it takes linear 
time.</P>
<H3 class=dtH1>Traversing the Nodes of a BST</H3>
<P>With the linear, contiguous ordering of an array's elements, iterating 
through an array is a straightforward manner: start at the first array element, 
and step through each element sequentially. For BSTs there are three different 
kinds of traversals that are commonly used: </P>
<UL type=disc>
  <LI>Preorder traversal 
  <LI>Inorder traversal 
  <LI>Postorder traversal </LI></UL>
<P>Essentially, all three traversals work in roughly the same manner. They start 
at the root and visit that node and its children. The difference among these 
three traversal methods is the order with which they visit the node itself 
versus visiting its children. To help clarify this, consider the BST in Figure 
11. (Note that the BST in Figure 11 is the same as the BST in Figure 6 and is 
repeated here for convenience.)</P>
<P class=fig><IMG alt="" src="Part 3 Binary Trees and BSTs.files/IC520.gif" 
border=0></P>
<P class=label><B>Figure 11. A sample Binary Search Tree</B></P>
<H4 class=dtH1>Preorder Traversal</H4>
<P>Preorder traversal starts by visiting the current node—call it <I>c</I>—then 
its left child, and then its right child. Starting with the BST's root as 
<I>c</I>, this algorithm can be written out as: </P>
<OL type=1>
  <LI>Visit <I>c</I>. This might mean printing out the value of the node, adding 
  the node to a List, or something else. It depends on what you want to 
  accomplish by traversing the BST. 
  <LI>Repeat step 1 using <I>c</I>'s left child. 
  <LI>Repeat step 1 using <I>c</I>'s right child. </LI></OL>
<P>Imagine that in step 1 of the algorithm we were printing out the value of 
<I>c</I>. In this case, what would the output be for a preorder traversal of the 
BST in Figure 11? Well, starting with step 1 we would print the root's value. 
Step 2 would have us repeat step 1 with the root's left child, so we'd print 50. 
Step 2 would have us repeat step 1 with the root's left child's left child, so 
we'd print 20. This would repeat all the way down the left side of the tree. 
When 5 was reached, we'd first print out its value (step 1). Since there are no 
left or right children of 5, we'd return to node 20, and perform its step 3, 
which is repeating step 1 with 20's right child, or 25. Since 25 has no 
children, we'd return to 20, but we've done all three steps for 20, so we'd 
return to 50, and then take on step 3 for node 50, which is repeating step 1 for 
node 50's right child. This process would continue on until each node in the BST 
had been visited. The output for a preorder traversal of the BST in Figure 11 
would be: 90, 50, 20, 5, 25, 75, 66, 80, 150, 95, 92, 111, 175, 166, 200.</P>
<P>Understandably, this may be a bit confusing. Perhaps looking at some code 
will help clarify things. The following code shows a method to iterate through 
the items of BST in a preorder traversal. Note that this method takes in a <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTreeNode</TT> class instance as 
one of its input parameters. This input node is the node <I>c</I> from the list 
of the algorithm's steps. Realize that a preorder traversal of the BST would 
begin by calling this method, passing in the BST's root.</P><PRE class=code>void PreorderTraversal(Node current)
{
   if (current != null)
   {
            // Output the value of the current node
      Console.WriteLine(current.Value);

            // Recursively print the left and right children
      PreorderTraversal(current.Left);
      PreorderTraversal(current.Right);
   }
}
</PRE>
<H4 class=dtH1>Inorder Traversal</H4>
<P>Inorder traversal starts by visiting the current node's left child, then the 
current node, and then its right child. Starting with the BST's root as 
<I>c</I>, this algorithm can be written out as: </P>
<OL type=1>
  <LI>Repeat step 1 using c's left child. 
  <LI>Visit c. This might mean printing out the value of the node, adding the 
  node to an ArrayList, or something else. It depends on what you want to 
  accomplish by traversing the BST. 
  <LI>Repeat step 1 using c's right child. </LI></OL>
<P>The code for <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">InorderTraversal()</TT> is just like 
<TT xmlns:asp="http://msdn2.microsoft.com/asp">PreorderTraversal()</TT> except 
that adding the <TT xmlns:asp="http://msdn2.microsoft.com/asp">current</TT> 
Node's data to the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">StringBuilder</TT> occurs 
<I>after</I> another call to <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">InorderTraversal()</TT>, passing in 
<TT xmlns:asp="http://msdn2.microsoft.com/asp">current</TT>'s left child.</P><PRE class=code>void InorderTraversal(Node current)
{
   if (current != null)
   {
            // Visit the left child...
      InorderTraversal(current.Left);

            // Output the value of the current node
      Console.WriteLine(current.Value);

            // Visit the right child...
      InorderTraversal(current.Right);
   }
}
</PRE>
<P>Applying an inorder traversal to the BST in Figure 11, the output would be: 
5, 20, 25, 50, 66, 75, 80, 90, 92, 95, 111, 150, 166, 175, 200. Note that the 
results returned are in ascending order.</P>
<H4 class=dtH1>Postorder Traversal</H4>
<P>Finally, postorder traversal starts by visiting the current node's left 
child, then its right child, and finally the current node itself. Starting with 
the BST's root as <I>c</I>, this algorithm can be written out as: </P>
<OL type=1>
  <LI>Repeat step 1 using c's left child. 
  <LI>Repeat step 1 using c's right child. 
  <LI>Visit c. This might mean printing out the value of the node, adding the 
  node to an ArrayList, or something else. It depends on what you want to 
  accomplish by traversing the BST. </LI></OL>
<P>The output of a postorder traversal for the BST in Figure 11 would be: 5, 25, 
20, 66, 80, 75, 50, 92, 111, 95, 166, 200, 175, 150, 90.</P>
<BLOCKQUOTE class=dtBlock><B>Note&nbsp;&nbsp;&nbsp;</B>The download included 
  with this article contains the complete source code for the <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">BinarySearchTree</TT> and <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTree</TT> classes, along with 
  a Windows Forms testing application for the BST class. Of particular interest, 
  the Windows Forms application allows you to view the contents of the BST in 
  either preorder, inorder, or postorder.</BLOCKQUOTE>
<P>Realize that all three traversal times exhibit linear asymptotic running 
time. This is because each traversal option visits each and every node in the 
BST precisely once. So, if the number of nodes in the BST are doubled, the 
amount of work for a traversal doubles as well.</P>
<H4 class=dtH1>The Cost of Recursion</H4>
<P>Recursive functions are often ideal for visualizing an algorithm, as they can 
often eloquently describe an algorithm in a few short lines of code. However, 
when iterating through a data structure's elements in practice, recursive 
functions are usually sub-optimal. Iterating through a data structure's elements 
involves stepping through the items and returning them to the developer 
utilizing the data structure, one at a time. Recursion is not suited to stopping 
abruptly at each step of the process. For this reason, the enumerator for the 
<TT xmlns:asp="http://msdn2.microsoft.com/asp">BinarySearchTree</TT> class uses 
a non-recursive solution to iterate through the elements.</P>
<H3 class=dtH1>Implementing a BST Class</H3>
<P>The .NET Framework Base Class Library does not include a binary search tree 
class, so let's create one ourselves. The <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BinarySearchTree</TT> class can reuse 
the <TT xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTreeNode</TT> class we 
examined earlier. Over the next few sections we'll look at each of the major 
methods of the class. For the class's full source code, be sure to download the 
source code that accompanies this article, which also includes a Windows Forms 
application for testing the BST class.</P>
<H4 class=dtH1>Searching for a Node</H4>
<P>The reason BSTs are important to study is that they offer sublinear search 
times. Therefore, it only makes sense to first examine the BSTs <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Contains()</TT> method. The <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Contains()</TT> method accepts a 
single input parameter and returns a Boolean indicating if that value exists in 
the BST.</P>
<P><TT xmlns:asp="http://msdn2.microsoft.com/asp">Contains()</TT> starts at the 
root and iteratively percolates down the tree until it either reaches a <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">null</TT> reference, in which case 
<TT xmlns:asp="http://msdn2.microsoft.com/asp">false</TT> is returned, or until 
it finds the node being searched for, in which case <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">true</TT> is returned. In the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">while</TT> loop, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Contains()</TT> compares the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Value</TT> of the current <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTreeNode</TT> instance against 
the data being searched for, and snakes its way down the right or left subtree 
accordingly. The comparison is performed by a private member variable, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">comparer</TT>, which is of type <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">IComparer&lt;T&gt;</TT> (where <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">T</TT> is the type defined via the 
Generics syntax for the BST). By default, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">comparer</TT> is assigned the default 
<TT xmlns:asp="http://msdn2.microsoft.com/asp">Comparer</TT> class for the type 
T, although the <TT xmlns:asp="http://msdn2.microsoft.com/asp">BST</TT> class's 
constructor has an overload to specify a custom <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Comparer</TT> class instance.</P><PRE class=code>public bool Contains(T data)
{
    // search the tree for a node that contains data
    BinaryTreeNode&lt;T&gt; current = root;
    int result;
    while (current != null)
    {
        result = comparer.Compare(current.Value, data);
        if (result == 0)
            // we found data
            return true;
        else if (result &gt; 0)
            // current.Value &gt; data, search current's left subtree
            current = current.Left;
        else if (result &lt; 0)
            // current.Value &lt; data, search current's right subtree
            current = current.Right;
    }

    return false;       // didn't find data
}
</PRE>
<H4 class=dtH1>Adding a Node to the BST</H4>
<P>Unlike the <TT xmlns:asp="http://msdn2.microsoft.com/asp">BinaryTree</TT> 
class we created earlier, the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BinarySearchTree</TT> class does not 
provide direct access to its root. Rather, nodes are added to the BST through 
the BST's <TT xmlns:asp="http://msdn2.microsoft.com/asp">Add()</TT> method. <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Add()</TT> takes as input the item to 
add to the BST, which is then percolated down the tree, looking for its new 
parent. (Recall that the any new nodes added to a BST will be added as leaf 
nodes.) Once the new node's parent is found, the node is made either the left or 
right child of the parent, depending on if its value is less than or greater 
than the parent's value.</P><PRE class=code>public virtual void Add(T data)
{
    // create a new Node instance
    BinaryTreeNode&lt;T&gt; n = new BinaryTreeNode&lt;T&gt;(data);
    int result;

    // now, insert n into the tree
    // trace down the tree until we hit a NULL
    BinaryTreeNode&lt;T&gt; current = root, parent = null;
    while (current != null)
    {
        result = comparer.Compare(current.Value, data);
        if (result == 0)
            // they are equal - attempting to enter a duplicate - do nothing
            return;
        else if (result &gt; 0)
        {
            // current.Value &gt; data, must add n to current's left subtree
            parent = current;
            current = current.Left;
        }
        else if (result &lt; 0)
        {
            // current.Value &lt; data, must add n to current's right subtree
            parent = current;
            current = current.Right;
        }
    }

    // We're ready to add the node!
    count++;
    if (parent == null)
        // the tree was empty, make n the root
        root = n;
    else
    {
        result = comparer.Compare(parent.Value, data);
        if (result &gt; 0)
            // parent.Value &gt; data, therefore n must be added to the left subtree
            parent.Left = n;
        else
            // parent.Value &lt; data, therefore n must be added to the right subtree
            parent.Right = n;
    }
}
</PRE>
<P>As you can see by examining the code, if the user attempts to add a duplicate 
the <TT xmlns:asp="http://msdn2.microsoft.com/asp">Add()</TT> method does 
nothing. That is, the BST cannot contain nodes with duplicate values. If you 
want, rather than simply returning, you could alter this code so inserting a 
duplicate raises an exception.</P>
<H4 class=dtH1>Deleting a Node from the BST</H4>
<P>Recall that deleting a node from a BST is the trickiest of the BST 
operations. The trickiness is due to the fact that deleting a node from a BST 
necessitates that a replacement node be chosen to occupy the space once held by 
the deleted node. Care must be taken when selecting this replacement node so 
that the binary search tree property is maintained.</P>
<P>Earlier, in the "Deleting Nodes from a BST" section, we discussed how there 
were three different scenarios for deciding what node to choose to replace the 
deleted node. These cases were summarized in Figure 10. Below you can see how 
the cases are identified and handled in the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Remove()</TT> method.</P><PRE class=code>public bool Remove(T data)
{
    // first make sure there exist some items in this tree
    if (root == null)
        return false;       // no items to remove

    // Now, try to find data in the tree
    BinaryTreeNode&lt;T&gt; current = root, parent = null;
    int result = comparer.Compare(current.Value, data);
    while (result != 0)
    {
        if (result &gt; 0)
        {
            // current.Value &gt; data, if data exists it's in the left subtree
            parent = current;
            current = current.Left;
        }
        else if (result &lt; 0)
        {
            // current.Value &lt; data, if data exists it's in the right subtree
            parent = current;
            current = current.Right;
        }

        // If current == null, then we didn't find the item to remove
        if (current == null)
            return false;
        else
            result = comparer.Compare(current.Value, data);
    }

    // At this point, we've found the node to remove
    count--;

    // We now need to "rethread" the tree
    // CASE 1: If current has no right child, then current's left child becomes
    //         the node pointed to by the parent
    if (current.Right == null)
    {
        if (parent == null)
            root = current.Left;
        else
        {
            result = comparer.Compare(parent.Value, current.Value);
            if (result &gt; 0)
                // parent.Value &gt; current.Value, so make current's left child a left child of parent
                parent.Left = current.Left;
            else if (result &lt; 0)
                // parent.Value &lt; current.Value, so make current's left child a right child of parent
                parent.Right = current.Left;
        }                
    }
    // CASE 2: If current's right child has no left child, then current's right child
    //         replaces current in the tree
    else if (current.Right.Left == null)
    {
        current.Right.Left = current.Left;

        if (parent == null)
            root = current.Right;
        else
        {
            result = comparer.Compare(parent.Value, current.Value);
            if (result &gt; 0)
                // parent.Value &gt; current.Value, so make current's right child a left child of parent
                parent.Left = current.Right;
            else if (result &lt; 0)
                // parent.Value &lt; current.Value, so make current's right child a right child of parent
                parent.Right = current.Right;
        }
    }
    // CASE 3: If current's right child has a left child, replace current with current's
    //          right child's left-most descendent
    else
    {
        // We first need to find the right node's left-most child
        BinaryTreeNode&lt;T&gt; leftmost = current.Right.Left, lmParent = current.Right;
        while (leftmost.Left != null)
        {
            lmParent = leftmost;
            leftmost = leftmost.Left;
        }

        // the parent's left subtree becomes the leftmost's right subtree
        lmParent.Left = leftmost.Right;

        // assign leftmost's left and right to current's left and right children
        leftmost.Left = current.Left;
        leftmost.Right = current.Right;

        if (parent == null)
            root = leftmost;
        else
        {
            result = comparer.Compare(parent.Value, current.Value);
            if (result &gt; 0)
                // parent.Value &gt; current.Value, so make leftmost a left child of parent
                parent.Left = leftmost;
            else if (result &lt; 0)
                // parent.Value &lt; current.Value, so make leftmost a right child of parent
                parent.Right = leftmost;
        }
    }

    return true;
}
</PRE>
<P>The <TT xmlns:asp="http://msdn2.microsoft.com/asp">Remove()</TT> method 
returns a Boolean to indicate whether or not the item was removed successfully 
from the binary search tree. False is returned in the case where the item to be 
removed was not found within the tree.</P>
<H4 class=dtH1>The Remaining BST Methods and Properties</H4>
<P>There are a few other BST methods and properties not examined here in this 
article. Be sure to download this article's accompanying code for a complete 
look at the BST class. The remaining methods and properties are: </P>
<UL type=disc>
  <LI><TT xmlns:asp="http://msdn2.microsoft.com/asp">Clear()</TT>: removes all 
  of the nodes from the BST. 
  <LI><TT xmlns:asp="http://msdn2.microsoft.com/asp">CopyTo(Array, index[, 
  TraversalMethods]): </TT>copies the contents of the BST to a passed-in array. 
  By default, an inorder traversal is used, although a specific traversal method 
  can be specified. The <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">TraversalMethods</TT> enumeration 
  options are <TT xmlns:asp="http://msdn2.microsoft.com/asp">Preorder</TT>, <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">Inorder</TT>, and <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">Postorder</TT>. 
  <LI><TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">GetEnumerator([TraversalMethods]):</TT> 
  provides iteration through the BST using inorder traversal, by default. Other 
  traversal methods can be optionally specified. 
  <LI><TT xmlns:asp="http://msdn2.microsoft.com/asp">Count</TT>: a public, 
  read-only property that returns the number of nodes in the BST. 
  <LI><TT xmlns:asp="http://msdn2.microsoft.com/asp">Preorder</TT>, <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">Inorder</TT>, and <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">Postorder:</TT> these three 
  properties return <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">IEnumerable&lt;T&gt;</TT> instances 
  that can be used to enumerate the items in the BST in a specified traversal 
  order. </LI></UL>
<P>The <TT xmlns:asp="http://msdn2.microsoft.com/asp">BST</TT> class implements 
the <TT xmlns:asp="http://msdn2.microsoft.com/asp">ICollection</TT>, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">ICollection&lt;T&gt;</TT>, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">IEnumerable</TT>, and <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">IEnumerable&lt;T&gt;</TT> 
interfaces.</P>
<H2 class=dtH1><A name=datastructures20_3_topic5></A>Binary Search Trees in the 
Real-World</H2>
<P>While binary search trees ideally exhibit sublinear running times for 
insertion, searches, and deletes, the running time is dependent upon the BST's 
topology. The topology, as we discussed in the "Inserting Nodes into a BST" 
section, is dependent upon the order with which the data is added to the BST. 
Data being entered that is ordered or near-ordered will cause the BST's topology 
to resemble a long, skinny tree, rather than a short and fat one. In many 
real-world scenarios, data is naturally in an ordered or near-ordered state.</P>
<P>The problem with BSTs is that they can become easily <I>unbalanced</I>. A 
<I>balaced</I> binary tree is one that exhibits a good ratio of breadth to 
depth. As we will examine in the next part of this article series, there are a 
special class of BSTs that are self-balancing. That is, as new nodes are added 
or existing nodes are deleted, these BSTs automatically adjust their topology to 
maintain an optimal balance. With an ideal balance, the running time for 
inserts, searches, and deletes, even in the worst case, is log<SUB>2</SUB> 
<I>n</I>. </P>
<P>In the next installment of this article series, we'll look at a couple 
self-balancing BST derivatives, including the red-black tree, and then focus on 
a data structure known as a SkipList, which exhibits the benefits of 
self-balancing binary trees, but without the need for restructuring the 
topology. Restructuring the topology, while efficient, requires a good deal of 
difficult code and is anything but readable.</P>
<P>Until then, happy programming!</P>
<H3 class=dtH1>Appendix A: Definitions</H3>
<P>The following table is an alphabetized list of definitions for terms used 
throughout this article.</P>
<DIV class=tablediv>
<TABLE class=dtTABLE>
  <TBODY>
  <TR vAlign=top>
    <TD width="23%">Binary tree</TD>
    <TD width="77%">A <I>tree</I> where each node has at most two 
  children.</TD></TR>
  <TR vAlign=top>
    <TD width="23%">Binary search tree</TD>
    <TD width="77%">A <I>binary tree</I> that exhibits the following property: 
      for any node <I>n</I>, every descendant node's value in the left 
      <I>subtree</I> of <I>n</I> is less than the value of <I>n</I>, and every 
      descendant node's value in the right <I>subtree</I> is greater than the 
      value of <I>n</I>.</TD></TR>
  <TR vAlign=top>
    <TD width="23%">Cycle</TD>
    <TD width="77%">A cycle exists if starting from some node <I>n</I> there 
      exists a path that returns to <I>n</I>.</TD></TR>
  <TR vAlign=top>
    <TD width="23%">Internal node</TD>
    <TD width="77%">A node that has one or more children.</TD></TR>
  <TR vAlign=top>
    <TD width="23%">Leaf node</TD>
    <TD width="77%">A node that has no children.</TD></TR>
  <TR vAlign=top>
    <TD width="23%">Node</TD>
    <TD width="77%">Nodes are the building blocks of <I>trees</I>. A node 
      contains some piece of data, a parent, and a set of children. (Note: the 
      <I>root</I> node does not contain a parent; <I>leaf</I> <I>nodes </I>do 
      not contain children.)</TD></TR>
  <TR vAlign=top>
    <TD width="23%">Root</TD>
    <TD width="77%">The node that has no parent. All trees contain precisely 
      one root.</TD></TR>
  <TR vAlign=top>
    <TD width="23%">Subtree</TD>
    <TD width="77%">A subtree rooted at node <I>n</I> is the tree formed by 
      imaging node <I>n</I> was a root. That is, the subtree's nodes are the 
      descendants of <I>n</I> and the subtree's root is <I>n</I> 
  itself.</TD></TR></TBODY></TABLE></DIV>
<H3 class=dtH1>Appendix B: Running Time Summaries</H3>
<P>The following table lists the common operations that are performed on a BST 
and their associated running times.</P>
<DIV class=tablediv>
<TABLE class=dtTABLE>
  <TBODY>
  <TR vAlign=top>
    <TD width="28%"><B>Operation</B></TD>
    <TD width="35%"><B>Best Case Running Time</B></TD>
    <TD width="37%"><B>Worst Case Running Time</B></TD></TR>
  <TR vAlign=top>
    <TD width="28%">Search</TD>
    <TD width="35%">log<SUB>2</SUB><I><SUB> </SUB>n</I></TD>
    <TD width="37%"><I>n</I></TD></TR>
  <TR vAlign=top>
    <TD width="28%">Insert</TD>
    <TD width="35%">log<SUB>2</SUB><I><SUB> </SUB>n</I></TD>
    <TD width="37%"><I>n</I></TD></TR>
  <TR vAlign=top>
    <TD width="28%">Delete</TD>
    <TD width="35%">log<SUB>2</SUB><I><SUB> </SUB>n</I></TD>
    <TD width="37%"><I>n</I></TD></TR>
  <TR vAlign=top>
    <TD width="28%">Preorder Traversal</TD>
    <TD width="35%">&nbsp;</TD>
    <TD width="37%"><I>n</I></TD></TR>
  <TR vAlign=top>
    <TD width="28%">Inorder Traversal</TD>
    <TD width="35%">&nbsp;</TD>
    <TD width="37%"><I>n</I></TD></TR>
  <TR vAlign=top>
    <TD width="28%">Postorder Traversal</TD>
    <TD width="35%">&nbsp;</TD>
    <TD width="37%"><I>n</I></TD></TR></TBODY></TABLE></DIV>
<H3 class=dtH1>References</H3>
<UL type=disc>
  <LI>Cormen, Thomas H., Charles E. Leiserson, and Ronald L. Rivest. 
  "Introduction to Algorithms." MIT Press. 1990. </LI></UL>
<P><B>Scott Mitchell</B>, author of six books and founder of 4GuysFromRolla.com, 
has been working with Microsoft Web technologies since January 1998. Scott works 
as an independent consultant, trainer, and writer, and holds a Masters degree in 
Computer Science from the University of California – San Diego. He can be 
reached at <A 
href="mailto:mitchell@4guysfromrolla.com">mitchell@4guysfromrolla.com</A>, or 
via his blog at <A 
href="http://scottonwriting.net/">http://scottonwriting.net/</A>.</P>
<DIV class=footer><BR>
<P></P>
<P><A href="http://msdn.microsoft.com/en-US/library/ms369863(v=VS.80).aspx">© 
Microsoft Corporation. All rights 
reserved.</A></P></DIV></DIV></DIV></DIV></DIV></DIV>
<DIV class=footer>
<DIV class="footerContainer cl_footer_slice" id=footer>
<DIV class=footerLogoContainer>
<DIV class=footerContent>
<DIV class=copyright>© 2011 Microsoft. All rights reserved.</DIV>
<DIV class="footerLogo cl_footer_logo"></DIV><A 
href="http://msdn.microsoft.com/cc300389.aspx">Terms of Use</A><SPAN class=pipe> 
| </SPAN><A 
href="http://www.microsoft.com/library/toolbar/3.0/trademarks/en-us.mspx">Trademarks</A><SPAN 
class=pipe> | </SPAN><A 
href="http://www.microsoft.com/info/privacy.mspx">Privacy Statement</A> <SPAN 
class=pipe>| </SPAN><A class=FeedbackLink title=Feedback 
onclick=javascript:ShowFeedbackDialog(); 
href="http://msdn.microsoft.com/en-US/library/ms379572(v=VS.80).aspx#footerLink">Feedback 
<SPAN class="FeedbackButton clip20x21" id=FeedbackButton><IMG 
class=cl_footer_feedback_icon alt=Feedback 
src="Part 3 Binary Trees and BSTs.files/a19e30a4020fe81d2b1209058013a360.png"> 
</SPAN></A>
<DIV class=FeedbackContainer id=FeedbackContainer><FORM 
action="/en-US/library/feedback/add/ms379572(v=VS.80).aspx" method="post">
<DIV class=FeedbackTitleContainer>
<DIV class=FeedbackTitle>Feedback</DIV>
<DIV class=FeedbackCancel><A 
onclick="document.getElementById('FeedbackContainer').style.display = 'none';" 
href="javascript:;">x</A> </DIV></DIV>
<DIV class=FeedbackData>
<DIV class=FeedbackInfoText>Tell us about your experience... </DIV>
<DIV class=QuestionText>Did the page load quickly? </DIV>
<DIV class=AnswerText><SPAN>Yes<SPAN> <INPUT id=searchBox type=radio value=1 
name=searchBox></SPAN></SPAN> <SPAN>No<SPAN> <INPUT id=searchBox type=radio 
value=0 name=searchBox></SPAN></SPAN> </DIV>
<DIV class=QuestionText>Do you like the page design? </DIV>
<DIV class=AnswerText><SPAN>Yes<SPAN> <INPUT id=tabbedCode type=radio value=1 
name=tabbedCode></SPAN></SPAN> <SPAN>No<SPAN> <INPUT id=tabbedCode type=radio 
value=0 name=tabbedCode></SPAN></SPAN> </DIV>
<DIV class=QuestionText>How useful is this topic? </DIV>
<DIV class="FeedbackGraphicHolder clip269x23"><IMG 
class="cl_online_scale FeedbackSiderGraphic" alt="" 
src="Part 3 Binary Trees and BSTs.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class=RadioButtonHolder>
<DIV class=RateRadioOne><INPUT id=topicUseful title="Really disliked it" 
type=radio value=1 name=topicUseful> </DIV>
<DIV class=RateRadio><INPUT id=topicUseful title="Disliked it" type=radio 
value=2 name=topicUseful> </DIV>
<DIV class=RateRadio><INPUT id=topicUseful title=OK type=radio value=3 
name=topicUseful> </DIV>
<DIV class=RateRadio><INPUT id=topicUseful title=Good type=radio value=4 
name=topicUseful> </DIV>
<DIV class=RateRadioLast><INPUT id=topicUseful title="Really Good" type=radio 
value=5 name=topicUseful> </DIV></DIV>
<DIV class=QuestionText>Tell us more </DIV>
<DIV class=FeedbackTextAreaContainer><TEXTAREA class=FeedbackTextArea onkeydown="LimitText(this, 4000);" onblur="document.onkeydown = Presskey;" onkeyup="LimitText(this, 4000);" onfocus="document.onkeydown = '';" name=feedbackText rows=5 cols=25></TEXTAREA> 
<TEXTAREA id=feedbackDescription onkeydown="LimitText(this, 4000);" onkeyup="LimitText(this, 4000);" style="DISPLAY: none" name=feedbackDescription rows=10 cols=25>Enter description here.</TEXTAREA> 
<INPUT id=feedbackPriority type=hidden name=feedbackPriority> <INPUT 
id=feedbackSourceUrl type=hidden name=feedbackSourceUrl> <INPUT id=ClientIP 
type=hidden name=ClientIP> <INPUT id=ClientOS type=hidden name=ClientOS> <INPUT 
id=ClientBrowser type=hidden name=ClientBrowser> <INPUT id=ClientTime 
type=hidden name=ClientTime> <INPUT id=ClientTimeZone type=hidden 
name=ClientTimeZone> </DIV>
<DIV><INPUT class=FeedbackSubmit onclick="document.getElementById('feedbackDescription').value='';document.getElementById('feedBackVersion').value = '-1';" type=submit value=Send> 
</DIV></DIV><INPUT id=returnUrl type=hidden 
value=http://msdn.microsoft.com/en-US/library/ms379572(v=VS.80).aspx 
name=returnUrl> <INPUT id=feedBackVersion type=hidden value=1 
name=feedBackVersion> </FORM></DIV></DIV></DIV></DIV></DIV>
<DIV class=MetricsContainer>
<DIV class=WebtrendsContainer>
<SCRIPT language=javascript type=text/javascript>
//<![CDATA[
  var literalNormalizedUrl = '/en-us/library/ms379572(d=lightweight,l=en-us,v=VS.80).aspx';
  var wt_nvr_ru = 'WT_NVR_RU';
  var wt_fpcdom = '.microsoft.com';
  var wt_domlist = 'msdn.microsoft.com';
  var wt_pathlist = '';
  var wt_paramlist = 'DCSext.mtps_devcenter';
  var wt_siteid = 'MSDN';
  var gDomain = 'm.webtrends.com';
  var gDcsId = 'dcsmgru7m99k7mqmgrhudo0k8_8c6m';
  var gFpc = 'WT_FPC';
  if (document.cookie.indexOf(gFpc + "=") == -1) {
    document.write("<scr" + "ipt type='text/javascript' src='" + "http" + (window.location.protocol.indexOf('https:') == 0 ? 's' : '') + "://" + gDomain + "/" + gDcsId + "/wtid.js" + "'><\\/scr" + "ipt>");
  }
  var detectedLocale = 'en-US';
  var wtsp = 'msdnlib_devtools_lang';
  var gTrackEvents = '0';
/*]]>*/
</SCRIPT>
<NOSCRIPT>
<DIV><IMG id=Img1 height=1 alt=DCSIMG 
src="Part 3 Binary Trees and BSTs.files/njs.gif" width=1></DIV></NOSCRIPT></DIV>
<DIV class=OmnitureContainer>
<SCRIPT type=text/javascript>
  var omni_guid = 'd0c7e4ff-eaa9-4b81-ae90-43e06422e7ca'; 
</SCRIPT>
<NOSCRIPT><A title="Web Analytics" href="http://www.omniture.com/"><IMG height=1 
alt="" src="Part 3 Binary Trees and BSTs.files/0.gif" width=1 border=0></A> 
</NOSCRIPT></DIV></DIV>
<SCRIPT language=javascript src="Part 3 Binary Trees and BSTs.files/broker.js" 
type=text/javascript></SCRIPT>

<SCRIPT 
src="Part 3 Binary Trees and BSTs.files/c2b4b2079ab4502f4c4e4b7eddfdc341.js" 
type=text/javascript xmlns="http://www.w3.org/1999/xhtml"></SCRIPT>
</BODY></HTML>
