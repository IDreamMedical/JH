<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0062)http://msdn.microsoft.com/en-US/library/ms379575(v=VS.80).aspx -->
<HTML xmlns="http://www.w3.org/1999/xhtml"><HEAD><TITLE>Part 6: Efficiently Representing Sets</TITLE><LINK 
href="http://msdn.microsoft.com/en-us/library/ms379575(v=vs.80).aspx" 
rel=canonical><LINK 
href="Part 6 Efficiently Representing Sets.files/024d86ac3c0dde3e6a230199128bdfe4.css" 
type=text/css rel=stylesheet><LINK media=print 
href="http://msdn.microsoft.com/en-US/library/ms379575(d=printer,v=VS.80).aspx" 
rel=alternate>
<META http-equiv=content-type content="text/html; charset=utf-8">
<META content=/en-us/library/ms379575(d=lightweight,l=en-us,v=VS.80).aspx 
name=DCS.dcsuri>
<META 
content=http://msdn.microsoft.com/en-us/library/ms379575(d=lightweight,l=en-us,v=VS.80).aspx 
name=NormalizedUrl>
<META 
content=http://msdn.microsoft.com/en-us/library/ms379575(l=en-us,v=VS.80).aspx 
name=VotingContextUrl>
<META content="C0384794-11:23:38 AM" name=MN>
<META content=ms379575 name=Search.ShortId>
<META content=en-us name=Ms.Locale>
<META content="MSHTML 6.00.2900.6049" name=GENERATOR></HEAD>
<BODY>
<DIV class=header>
<TABLE class="headerBar cl_lightweight_topnav_slice" cellSpacing=0 cellPadding=0 
border=0>
  <TBODY>
  <TR>
    <TD 
    class="leftSection cl_lightweight_header_leftSection_wave leftSectionImageClusterOverride">
      <DIV class=tabContainer><A class=" headerTab" title=Home 
      href="http://msdn.microsoft.com/en-US/">Home</A> <A 
      class="headerTabSelected cl_lightweight_selected_tab_repeatX " 
      title=Library href="http://msdn.microsoft.com/en-US/library">Library</A> 
      <A class=" headerTab" title=Learn 
      href="http://msdn.microsoft.com/en-US/bb188199.aspx">Learn</A> <A 
      class=" headerTab" title=Downloads 
      href="http://msdn.microsoft.com/en-US/aa570309.aspx">Downloads</A> <A 
      class=" headerTab" title=Support 
      href="http://msdn.microsoft.com/en-US/aa570318.aspx">Support</A> <A 
      class=" headerTab" title=Community 
      href="http://msdn.microsoft.com/en-US/aa497440.aspx">Community</A> 
    </DIV></TD>
    <TD 
    class="rightSection cl_lightweight_header_rightSection_wave rightSectionImageClusterOverride">
      <DIV class=tabContainer><A title="Sign in" 
      href="https://login.live.com/login.srf?wa=wsignin1.0&amp;rpsnv=11&amp;ct=1303496618&amp;rver=6.0.5276.0&amp;wp=MCLBI&amp;wlcxt=msdn%24msdn%24msdn&amp;wreply=http:%2F%2Fmsdn.microsoft.com%2Fen-US%2Flibrary%2Fms379575%2528v%3DVS.80%2529.aspx&amp;lc=1033&amp;cb=&amp;id=254354">Sign 
      in </A><SPAN class=pipe>|</SPAN> <A title=中国（简体中文） 
      href="http://msdn.microsoft.com/en-US/library/preferences/locale/?returnurl=%252fen-US%252flibrary%252fms379575(v%253dVS.80).aspx">中国（简体中文） 
      </A><SPAN class=pipe>|</SPAN> <A title=Preferences 
      href="http://msdn.microsoft.com/en-US/library/preferences/experience/?returnurl=%252fen-US%252flibrary%252fms379575(v%253dVS.80).aspx">Preferences</A> 
      </DIV></TD></TR></TBODY></TABLE></DIV>
<DIV class=contentPlaceHolder>
<DIV class=navigation id=Navigation style="PADDING-BOTTOM: 96px; WIDTH: 280px">
<DIV class=searchcontainer>
<FORM id=SearchForm 
style="PADDING-RIGHT: 0px; PADDING-LEFT: 0px; PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-TOP: 0px" 
action=http://social.msdn.microsoft.com/Search/en-US method=get>
<DIV class=searchBoxContainer>
<TABLE class=searchBox cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD class=searchTextBoxTd><INPUT class=searchTextBox id=searchTextBox 
      onblur="document.onkeydown = Presskey;WatermarkBlur(this, 'Search MSDN with Bing', 'searchTextBox')" 
      onfocus="document.onkeydown = ''; WatermarkFocus(this, 'Search MSDN with Bing', 'searchTextBoxTrue') " 
      maxLength=200 value="Search MSDN with Bing" name=query> </TD>
    <TD class=searchButtonTd><A 
      style="PADDING-RIGHT: 0px; DISPLAY: block; PADDING-LEFT: 0px; PADDING-BOTTOM: 0px; MARGIN: 0px; OVERFLOW: hidden; WIDTH: 19px; PADDING-TOP: 0px; POSITION: relative; HEIGHT: 19px" 
      onclick="javascript:if(document.getElementById('searchTextBox').value == 'Search MSDN with Bing')document.getElementById('searchTextBox').value=''; document.getElementById('SearchForm').submit();" 
      href="javascript:void(0)"><IMG class=cl_search_icon title=Search 
      style="POSITION: relative" alt=Search 
      src="Part 6 Efficiently Representing Sets.files/a19e30a4020fe81d2b1209058013a360.png"></A> 
    </TD></TR></TBODY></TABLE></DIV></FORM></DIV>
<DIV class=navcontainer>
<DIV class=nav>
<DIV class="toclevel0 ancestry">
<DIV class="clip5x9 nav_root"><IMG class=cl_nav_bullet alt="" 
src="Part 6 Efficiently Representing Sets.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class=nav_div_currentroot><A title="MSDN Library" 
href="http://msdn.microsoft.com/en-us/library/ms123401.aspx">MSDN 
Library</A></DIV>
<DIV class="clip5x9 nav_arrows"><IMG class=cl_nav_arrow alt="" 
src="Part 6 Efficiently Representing Sets.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class=nav_div_currentroot><A title="Development Tools and Languages" 
href="http://msdn.microsoft.com/en-us/library/aa187916.aspx">Development Tools 
and Languages</A></DIV>
<DIV class="clip5x9 nav_arrows"><IMG class=cl_nav_arrow alt="" 
src="Part 6 Efficiently Representing Sets.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class=nav_div_currentroot><A title="Visual Studio 2005" 
href="http://msdn.microsoft.com/en-us/library/ms950416.aspx">Visual Studio 
2005</A></DIV>
<DIV class="clip5x9 nav_arrows"><IMG class=cl_nav_arrow alt="" 
src="Part 6 Efficiently Representing Sets.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class=nav_div_currentroot><A title="Technical Articles" 
href="http://msdn.microsoft.com/en-us/library/aa468085.aspx">Technical 
Articles</A></DIV>
<DIV class="clip5x9 nav_arrows"><IMG class=cl_nav_arrow alt="" 
src="Part 6 Efficiently Representing Sets.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class=nav_div_currentroot><A title=C# 
href="http://msdn.microsoft.com/en-us/library/ms391942(v=VS.80).aspx">C#</A></DIV>
<DIV class="clip5x9 nav_arrows"><IMG class=cl_nav_arrow alt="" 
src="Part 6 Efficiently Representing Sets.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class=nav_div_currentroot><A 
title="An Extensive Examination of Data Structures Using C# 2.0" 
href="http://msdn.microsoft.com/en-us/library/ms364091(v=VS.80).aspx">An 
Extensive Examination of Data Structures Using C# 2.0</A></DIV></DIV>
<DIV class="clip13x9 nav_dots_current"><IMG class=cl_nav_dots alt="" 
src="Part 6 Efficiently Representing Sets.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class="toclevel1 current"><A title="Part 6: Efficiently Representing Sets" 
href="http://msdn.microsoft.com/en-us/library/ms379575(v=VS.80).aspx">Part 6: 
Efficiently Representing Sets</A></DIV>
<DIV class="toclevel2 children" 
style="BORDER-BOTTOM: #bbbbbb 1px solid"></DIV><IMG 
class="communityContentNavigationSeparator cl_lt_cc_line_top" alt=Separator 
src="Part 6 Efficiently Representing Sets.files/030c41d9079671d09a62d8e2c1db6973.gif"> 
</DIV></DIV></DIV><A class=tocResize id=TocResize style="LEFT: 280px" 
onclick=onIncreaseToc() 
href="http://msdn.microsoft.com/en-US/library/ms379575(v=VS.80).aspx#"><IMG 
class=cl_nav_resize_open onmousedown=onIncreaseToc() id=ResizeImageIncrease 
title=Expand alt=Expand 
src="Part 6 Efficiently Representing Sets.files/a19e30a4020fe81d2b1209058013a360.png"> 
<IMG class=cl_nav_resize_close onmousedown=onResetToc() id=ResizeImageReset 
title=Minimize style="DISPLAY: none" alt=Minimize 
src="Part 6 Efficiently Representing Sets.files/a19e30a4020fe81d2b1209058013a360.png"> 
</A>
<DIV class=content><IMG class="TOC_Fade_Top cl_lw_toc_fade_top" alt="" 
src="Part 6 Efficiently Representing Sets.files/030c41d9079671d09a62d8e2c1db6973.gif"> 

<DIV class="clip117x31 logo"><A 
href="http://msdn.microsoft.com/en-US/default.aspx"><IMG class=msdn_body_logo 
title=MSDN alt=MSDN 
src="Part 6 Efficiently Representing Sets.files/a19e30a4020fe81d2b1209058013a360.png"> 
</A></DIV>
<DIV class=topicContainer>
<DIV class=topic xmlns="http://www.w3.org/1999/xhtml" 
xmlns:mtps="http://msdn2.microsoft.com/mtps">
<H1 class=title>An Extensive Examination of Data Structures Using C# 2.0</H1>
<DIV class=lw_vs>
<DIV id=curversion><STRONG>Visual Studio 2005</STRONG> </DIV></DIV>
<DIV style="CLEAR: right"></DIV>
<DIV id=nstext valign="bottom">&nbsp; 
<P>Scott Mitchell<BR>4GuysFromRolla.com</P>
<P>Update January 2005</P>
<P><B>Summary: </B>This sixth installment of the article series examines how to 
implement a common mathematical construct, the set. A set is an unordered 
collection of unique items that can be enumerated and compared to other sets in 
a variety of ways. In this article we'll look at data structures for 
implementing general sets as well as disjoint sets. (20 printed pages)</P>
<FORM name=x>
<P><A 
href="http://download.microsoft.com/download/5/0/f/50f7b985-990b-4154-ac21-518bfe16f887/DataStructures20.msi">Download 
the DataStructures20.msi sample file</A>.</P>
<BLOCKQUOTE class=dtBlock><B>Editor's note&nbsp;&nbsp;&nbsp;</B>This six-part 
  article series originally appeared on MSDN Online starting in November 2003. 
  In January 2005 it was updated to take advantage of the new data structures 
  and features available with the .NET Framework version 2.0, and C# 2.0. The 
  original articles are still available at <A 
  href="http://msdn.microsoft.com/vcsharp/default.aspx?pull=/library/en-us/dv_vstechart/html/datastructures_guide.asp">http://msdn.microsoft.com/vcsharp/default.aspx?pull=/library/en-us/dv_vstechart/html/datastructures_guide.asp</A>. 
</BLOCKQUOTE>
<BLOCKQUOTE class=dtBlock><B>Note&nbsp;&nbsp;&nbsp;</B>This article assumes 
  the reader is familiar with C#.</BLOCKQUOTE>
<H4 class=dtH1>Contents</H4>
<P><A 
href="http://msdn.microsoft.com/en-US/library/ms379575(v=VS.80).aspx#datastructures20_6_topic1">Introduction</A><BR><A 
href="http://msdn.microsoft.com/en-US/library/ms379575(v=VS.80).aspx#datastructures20_6_topic2">The 
Fundamentals of Sets</A><BR><A 
href="http://msdn.microsoft.com/en-US/library/ms379575(v=VS.80).aspx#datastructures20_6_topic3">Implementing 
an Efficient Set Data Structure</A><BR><A 
href="http://msdn.microsoft.com/en-US/library/ms379575(v=VS.80).aspx#datastructures20_6_topic4">Maintaining 
a Collection of Disjoint Sets</A></P>
<H2 class=dtH1><A name=datastructures20_6_topic1></A>Introduction</H2>
<P>One of the most basic mathematical constructs is a <I>set</I>, which is an 
unordered collection of unique objects. The objects contained within a set are 
referred to as the set's <I>elements</I>. Formally, a set is denoted as a 
capital, italic letter, with its elements appearing within curly braces (<TT 
xmlns:asp="http://msdn2.microsoft.com/asp">{...}</TT>). Examples of this 
notation can be seen below:</P><PRE class=code><I>S</I> = { 1, 3, 5, 7, 9 }
<I>T</I> = { Scott, Jisun, Sam }
<I>U</I> = { -4, 3.14159, Todd, <I>x</I> }
</PRE>
<P>In mathematics, typically sets are comprised strictly of numbers, such as set 
<I>S</I> above, which contains the odd positive integers less than 10. But 
notice that the elements of a set can be anything—numbers, people, strings, 
letters, variables, and so on. Set <I>T</I>, for example, contains peoples' 
names; set <I>U</I> contains a mix of numbers, names, and variables.</P>
<P>In this article we'll start with a basic introduction of sets, including 
common notation and the operations that can be performed on sets. Following 
that, we'll examine how to efficiently implement a set data structure with a 
defined universe. The article concludes with an examination of disjoint sets, 
and the best data structures to use.</P>
<H2 class=dtH1><A name=datastructures20_6_topic2></A>The Fundamentals of 
Sets</H2>
<P>Recall that a set is simple a collection of elements. The "element of" 
operator, denoted <I>x</I> <SPAN style="FONT-FAMILY: Symbol">Î</SPAN> <I>S</I>, 
implies that <I>x</I> is an element in the set <I>S</I>. For example, if set 
<I>S</I> contains the odd positive integers less than 10, then 1<SPAN 
style="FONT-FAMILY: Symbol">Î</SPAN> <I>S</I>. When reading such notation, you'd 
say, "1 is an element of <I>S</I>." In addition to 1 being an element of 
<I>S</I>, we have 3 <SPAN style="FONT-FAMILY: Symbol">Î</SPAN> <I>S</I>, 5 <SPAN 
style="FONT-FAMILY: Symbol">Î</SPAN> <I>S</I>, 7 <SPAN 
style="FONT-FAMILY: Symbol">Î</SPAN> <I>S</I>, and 9 <SPAN 
style="FONT-FAMILY: Symbol">Î</SPAN> <I>S</I>. The "not and element of" 
operator, denoted <I>x</I> <SPAN style="FONT-FAMILY: Symbol">Ï</SPAN> <I>S</I>, 
means that <I>x</I> is not an element of set <I>S</I>. </P>
<P>The number of unique elements in a set is the set's <I>cardinality</I>. The 
set {1, 2, 3} has cardinality 3, just as does the set {1, 1, 1, 1, 1, 1, 1, 2, 
3} (because it only has three unique elements). A set may have no elements in it 
at all. Such a set is called the <I>empty set</I>, and is denoted as {} or <SPAN 
style="FONT-FAMILY: Symbol">Æ</SPAN>, and has a cardinality of 0.</P>
<P>When first learning about sets, many developers assume they are tantamount to 
collections, like a List. However, there are some subtle differences. A List is 
an <I>ordered</I> collection of elements. Each element in a List has an 
associated ordinal index, which implies order. Too, there can be duplicate 
elements in a List. </P>
<P>A set, on the other hand, is <I>unordered</I> and contains <I>unique</I> 
items. Because sets are unordered, the elements of a set may be listed in any 
order. That is, the sets {1, 2, 3} and {3, 1, 2} are considered equivalent. 
Also, any duplicates in a set are considered redundant. The set {1, 1, 1, 2, 3} 
and the set {1, 2, 3} are equivalent. Two sets are equivalent if they have the 
same elements. (Equivalence is denoted with the = sign; if S and T are 
equivalent they are written as <I>S</I> = <I>T</I>.)</P>
<BLOCKQUOTE class=dtBlock><B>Note&nbsp;&nbsp;&nbsp;</B>In mathematics, an 
  <I>ordered</I> collection of elements that allows duplicates is referred to as 
  a <I>list</I>. Two lists, <I>L</I><SUB>1</SUB> and <I>L</I><SUB>2</SUB> are 
  considered equal if and only if for <I>i</I> ranging from 1 to the number of 
  elements in the list the <I>i</I>th element in <I>L</I><SUB>1</SUB> equals the 
  <I>i</I>th element in <I>L</I><SUB>2</SUB>.</BLOCKQUOTE>
<P>Typically the elements that can appear in a set are restricted to some 
<I>universe</I>. The universe is the set of all possible values that can appear 
in a set. For example, we might only be interested in working with sets whose 
universe are integers. By restricting the universe to integers, we can't have a 
set that has a non-integer element, like 8.125, or Sam. (The universe is denoted 
as the set <I>U</I>.)</P>
<H3 class=dtH1>Relational Operators of Sets</H3>
<P>There are a bevy of relational operators that are commonly used with numbers. 
Some of the more often used ones, especially in programming languages, include 
<TT xmlns:asp="http://msdn2.microsoft.com/asp">&lt;</TT>, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">&lt;=</TT>, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">=</TT>, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">!=</TT>, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">&gt;</TT>, and <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">&gt;=</TT>. A relational operator 
determines if the operand on the left hand side is related to the operand on the 
right hand side based on criteria defined by the relational operator. Relational 
operators return a "true" or "false" value, indicating whether or not the 
relationship holds between the operands. For example, <I>x</I> &lt; <I>y</I> 
returns true if <I>x</I> is less than <I>y</I>, and false otherwise. (Of course 
the meaning of "less than" depends on the data type of <I>x</I> and 
<I>y</I>.)</P>
<P>Relational operators like <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">&lt;</TT>, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">&lt;=</TT>, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">=</TT>, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">!=</TT>, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">&gt;</TT>, and <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">&gt;=</TT> are typically used with 
numbers. Sets, as we've seen, use the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">=</TT> relational operator to 
indicate that two sets are equivalent (and can likewise use <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">!=</TT> to denote that two sets are 
not equivalent), but relational operators <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">&lt;</TT>, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">&lt;=</TT>, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">&gt;</TT>, and <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">&gt;=</TT> are not defined for sets. 
After all, how is one to determine if the set {1, 2, 3} is less than the set 
{Scott, 3.14159}?</P>
<P>Instead of notions of <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">&lt;</TT> and <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">&lt;=</TT>, sets use the relational 
operators <I>subset</I> and <I>proper subset</I>, denoted <SPAN 
style="FONT-FAMILY: Symbol">Í</SPAN> and <SPAN 
style="FONT-FAMILY: Symbol">Ì</SPAN>, respectively. (Some older texts will use 
<SPAN style="FONT-FAMILY: Symbol">Ì</SPAN> for subset and <SPAN 
style="FONT-FAMILY: Symbol">Í</SPAN> for proper subset.) <I>S</I> is a subset of 
<I>T</I>—denoted <I>S</I> <SPAN style="FONT-FAMILY: Symbol">Í</SPAN> <I>T</I>—if 
every element in <I>S</I> is in <I>T</I>. That is, <I>S</I> is a subset of 
<I>T</I> if it is <I>contained</I> within <I>T</I>. If <I>S</I> = {1, 2, 3}, and 
<I>T</I> = {0, 1, 2, 3, 4, 5}, then <I>S</I> <SPAN 
style="FONT-FAMILY: Symbol">Í</SPAN> <I>T</I> because every element in <I>S</I> 
– 1, 2 and 3—is an element in <I>T</I>. <I>S</I> is a proper subset of 
<I>T</I>—denoted <I>S</I> <SPAN style="FONT-FAMILY: Symbol">Ì</SPAN> <I>T</I>—if 
<I>S</I> <SPAN style="FONT-FAMILY: Symbol">Í</SPAN> <I>T</I> and <I>S</I> <SPAN 
style="FONT-FAMILY: Symbol">¹</SPAN> <I>T</I>. That is, if <I>S</I> = {1, 2, 3} 
and <I>T</I> = {1, 2, 3}, then <I>S</I> <SPAN 
style="FONT-FAMILY: Symbol">Í</SPAN> <I>T</I> because every element in <I>S</I> 
is an element in <I>T</I>, but <I>S</I> <SPAN 
style="FONT-FAMILY: Symbol">Ë</SPAN> <I>T</I> because <I>S</I> = <I>T</I>. 
(Notice that there is a similarity between the relational operators <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">&lt;</TT> and <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">&lt;=</TT> for numbers and the 
relational operators <SPAN style="FONT-FAMILY: Symbol">Ì</SPAN> and <SPAN 
style="FONT-FAMILY: Symbol">Í</SPAN> for sets.)</P>
<P>Using the new subset operator, we can more formally define set equality. 
Given sets <I>S</I> and <I>T</I>, <I>S</I> = <I>T</I> if and only if <I>S</I> 
<SPAN style="FONT-FAMILY: Symbol">Í</SPAN> <I>T </I>and <I>T</I> <SPAN 
style="FONT-FAMILY: Symbol">Í</SPAN> <I>S</I>. In English, <I>S</I> and <I>T</I> 
are equivalent if and only if every element in <I>S</I> is in <I>T</I>, and 
every element in <I>T</I> is in <I>S</I>.</P>
<BLOCKQUOTE class=dtBlock><B>Note&nbsp;&nbsp;&nbsp;</B>Because <SPAN 
  style="FONT-FAMILY: Symbol">Í</SPAN> is analogous to <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">&lt;=</TT>, it would make sense 
  that there exists a set relational operator analogous to <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">&gt;=</TT>. This relational 
  operator is called <I>superset</I>, and is denoted <SPAN 
  style="FONT-FAMILY: Symbol">Ê</SPAN>; a <I>proper superset</I> is denoted 
  <SPAN style="FONT-FAMILY: Symbol">É</SPAN>. Like with <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">&lt;=</TT> and <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">&gt;=</TT>, <I>S</I> <SPAN 
  style="FONT-FAMILY: Symbol">Ê</SPAN> <I>T</I> if and only if <I>T</I> <SPAN 
  style="FONT-FAMILY: Symbol">Í</SPAN> <I>S</I>.</BLOCKQUOTE>
<H3 class=dtH1>Set Operations</H3>
<P>As with the relational operators, many operations defined for numbers don't 
translate well to sets. Common operations on numbers include addition, 
multiplication, subtraction, exponentiation, and so on. For sets, there are four 
basic operations: </P>
<OL type=1>
  <LI><B>Union:</B> the union of two sets, denoted <I>S</I> <SPAN 
  style="FONT-FAMILY: Symbol">È</SPAN> <I>T</I>, is akin to addition for 
  numbers. The union operator returns a set that contains all of the elements in 
  <I>S</I> and all of the elements in <I>T</I>. For example, {1, 2, 3} <SPAN 
  style="FONT-FAMILY: Symbol">È</SPAN> {2, 4, 6} equals {1, 2, 3, 2, 4, 6}. (The 
  duplicate 2 can be removed to provide a more concise answer, yielding {1, 2, 
  3, 4, 6}.) Formally, <I>S</I> <SPAN style="FONT-FAMILY: Symbol">È</SPAN> 
  <I>T</I> = {<I>x</I> : <I>x</I> <SPAN style="FONT-FAMILY: Symbol">Î</SPAN> 
  <I>S </I>or <I>x</I> <SPAN style="FONT-FAMILY: Symbol">Î</SPAN> <I>T</I>}. In 
  English, this translates to <I>S</I> union <I>T</I> results in the set that 
  contains an element <I>x</I> if <I>x</I> is in <I>S</I> or in <I>T</I>. 
  <LI><B>Intersection:<I> </I></B>the intersection of two sets, denoted <I>S</I> 
  <SPAN style="FONT-FAMILY: Symbol">Ç</SPAN> <I>T</I>, is the set of elements 
  that <I>S</I> and <I>T</I> have in common. For example, {1, 2, 3} <SPAN 
  style="FONT-FAMILY: Symbol">Ç</SPAN> {2, 4, 6} equals {2}, because that's the 
  only element both {1, 2, 3} and {2, 4, 6} share in common. Formally, <I>S</I> 
  <SPAN style="FONT-FAMILY: Symbol">Ç</SPAN> <I>T</I> = {<I>x</I> : <I>x</I> 
  <SPAN style="FONT-FAMILY: Symbol">Î</SPAN> <I>S </I>and <I>x</I> <SPAN 
  style="FONT-FAMILY: Symbol">Î</SPAN> <I>T</I>}. In English, this translates to 
  <I>S</I> intersect <I>T</I> results in the set that contains an element 
  <I>x</I> if <I>x</I> is both in <I>S</I> <B>and</B> in <I>T</I>. 
  <LI><B>Difference:</B> the difference of two sets, denoted <I>S</I> – 
  <I>T</I>, are all of the elements in <I>S</I> that are <B>not</B> in <I>T</I>. 
  For example, {1, 2, 3} – {2, 4, 6} equals {1, 3}, because 1 and 3 are the 
  elements in <I>S</I> that are not in <I>T</I>. Formally, <I>S – T</I> = 
  {<I>x</I> : <I>x</I> <SPAN style="FONT-FAMILY: Symbol">Î</SPAN> <I>S </I>and 
  <I>x</I> <SPAN style="FONT-FAMILY: Symbol">Ï</SPAN> <I>T</I>}. In English, 
  <I>S</I> set difference <I>T</I> results in the set that contains an element 
  <I>x</I> if <I>x</I> is in <I>S</I> and <B>not</B> in <I>T</I>. 
  <LI><B>Complement:</B> Earlier we discussed how typically sets are limited to 
  a known universe of possible values, such as the integers. The complement of a 
  set, denoted <I>S</I>', is <I>U</I> – <I>S</I>. (Recall that <I>U</I> is the 
  universe set.) If our universe is the integers 1 through 10, and <I>S</I> = 
  {1, 4, 9, 10}, then <I>S</I>' = {2, 3, 5, 6, 7, 8}. Complementing a set is 
  akin to negating a number. Just like negating a number twice will give you the 
  original number back. That is, --<I>x</I> = <I>x</I> – complementing a set 
  twice will give you the original set back – <I>S</I>'' = <I>S</I>. </LI></OL>
<P>When examining new operations, it is always important to get a solid grasp on 
the nature of the operations. Some questions to ask yourself when learning about 
any operation, be it one defined for numbers or one defined for sets, are: </P>
<UL type=disc>
  <LI><B>Is the operation commutative?</B> An operator <I>op</I> is commutative 
  if <I>x</I> <I>op</I> <I>y</I> is equivalent to <I>y</I> <I>op x</I>. In the 
  realm of numbers, addition is an example of a commutative operator, while 
  division is not commutative. 
  <LI><B>Is the operation associative?</B> That is, does the order of operations 
  matter. If an operator <I>op</I> is associative, then <I>x op </I>(<I>y op 
  z</I>) is equivalent to (<I>x op y</I>) <I>op z</I>. Again, in the realm of 
  numbers addition is associative, but division is not. </LI></UL>
<P>For sets, the union and intersection operations are both commutative and 
associative. <I>S</I> <SPAN style="FONT-FAMILY: Symbol">È</SPAN> <I>T</I> is 
equivalent to <I>T</I> <SPAN style="FONT-FAMILY: Symbol">È</SPAN> <I>S</I>, and 
<I>S </I><SPAN style="FONT-FAMILY: Symbol">È</SPAN> (<I>T</I> <SPAN 
style="FONT-FAMILY: Symbol">È</SPAN> <I>V</I>) is equivalent to (<I>S</I> <SPAN 
style="FONT-FAMILY: Symbol">È</SPAN> <I>T</I>) <SPAN 
style="FONT-FAMILY: Symbol">È</SPAN> <I>V</I>. Set difference, however, is 
neither commutative nor associative. (To see that set difference is not 
commutative, consider that {1, 2, 3} – {3, 4, 5} = {1, 2}, but {3, 4, 5} – {1, 
2, 3} = {4, 5}.)</P>
<H3 class=dtH1>Finite Sets and Infinite Sets</H3>
<P>All of the set examples we've looked at thus far have dealt with finite sets. 
A finite set is a set that has a finite number of elements. While it may seem 
counterintuitive at first, a set can contain an infinite number of elements. The 
set of positive integers, for example, is an infinite set because there is no 
bounds to the number of elements in the set.</P>
<P>In mathematics, there are a couple infinite sets that are used so often that 
they are given a special symbol to represent them. These include:</P>
<P><SPAN style="FONT-FAMILY: Lucida Sans Unicode">N</SPAN> = {0, 1, 2, ...}</P>
<P><SPAN style="FONT-FAMILY: Lucida Sans Unicode">Z</SPAN> = {..., -2, -1, 0, 1, 
2, ...}</P>
<P><SPAN style="FONT-FAMILY: Lucida Sans Unicode">Q</SPAN> = {a/b: a <SPAN 
style="FONT-FAMILY: Symbol">Î</SPAN> <SPAN 
style="FONT-FAMILY: Lucida Sans Unicode">Z</SPAN>, b <SPAN 
style="FONT-FAMILY: Symbol">Î</SPAN> <SPAN 
style="FONT-FAMILY: Lucida Sans Unicode">Z</SPAN>, and b <SPAN 
style="FONT-FAMILY: Symbol">¹</SPAN> 0}</P>
<P><SPAN style="FONT-FAMILY: Lucida Sans Unicode">R</SPAN> = <I>set of real 
numbers</I></P>
<P><SPAN style="FONT-FAMILY: Lucida Sans Unicode">N</SPAN> is the set of 
<I>natural numbers</I>, or positive integers greater than or equal to 0. <SPAN 
style="FONT-FAMILY: Lucida Sans Unicode">z</SPAN> is the set of <I>integers</I>. 
<SPAN style="FONT-FAMILY: Lucida Sans Unicode">N</SPAN> is the set of 
<I>rational numbers</I>, which are numbers that can be expressed as a fraction 
of two integers. Finally, <SPAN 
style="FONT-FAMILY: Lucida Sans Unicode">R</SPAN> is the set of <I>real 
numbers</I>, which are all rational numbers, plus irrational numbers as well 
(numbers that cannot be expressed as a fraction of two integers, such as 
<I>pi</I>, and the square root of 2).</P>
<P>Infinite sets, of course, can't be written down in their entirety, as you'd 
never finish jotting down the elements, but instead are expressed more tersely 
using mathematical notation like so:</P><PRE class=code><I>S</I> = {<I>x</I> : <I>x</I><SPAN style="FONT-FAMILY: Symbol">Î</SPAN> <SPAN style="FONT-FAMILY: Lucida Sans Unicode">N</SPAN> and <I>x</I> &gt; 100}
</PRE>
<P>Here <I>S</I> would be the set of all natural numbers greater than 100.</P>
<P>In this article we will be looking at data structures for representing finite 
sets. While infinite sets definitely have their place in mathematics, rarely 
will we need to work with infinite sets in a computer program. Too, there are 
unique challenges with representing and operating upon infinite sets, because an 
infinite set's contents cannot be completely stored in a data structure or 
enumerated.</P>
<BLOCKQUOTE class=dtBlock><B>Note&nbsp;&nbsp;&nbsp;</B>Computing the 
  cardinality of finite sets is simple. Just count up the number of elements in 
  the set. But how does one compute the cardinality of an infinite set? This 
  discussion is far beyond the scope of this article, but realize that there's 
  different types of cardinality for infinite sets. For instance, the set of 
  positive integers has the same cardinality as the set of <B>all</B> integers, 
  but the set of real numbers has a larger cardinality than the set of all 
  integers.</BLOCKQUOTE>
<H3 class=dtH1>Sets in Programming Languages</H3>
<P>C++, C#, Visual Basic .NET, and Java don't provide inherent language features 
for working with sets. If you want to use sets, you need to create your own set 
class with the appropriate methods, properties, and logic. (We'll do precisely 
this in the next section.) There have been programming languages in the past, 
though, that have offered sets as a fundamental building block in the language. 
Pascal, for example, provides a set construct that can be used to create sets 
with an explicitly defined universe. To work with sets, Pascal provides the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">in</TT> operator to determine if an 
element is in a particular set. The operators <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">+</TT>, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">*</TT>, and <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">–</TT> are used for union, 
intersection, and set difference, respectively. The following Pascal code 
illustrates the syntax used to work with sets:</P><PRE class=code>/* declares a variable named possibleNumbers, a set whose universe is the 
  set of integers between 1 and 100... */
var  
  possibleNumbers = set of 1..100;

...

/* Assigns the set {1, 45, 23, 87, 14} to possibleNumbers */
possibleNumbers := [1, 45, 23, 87, 14];

/* Sets possibleNumbers to the union of possibleNumbers and {3, 98} */
possibleNumbers := possibleNumbers + [3, 98];

/* Checks to see if 4 is an element of possible numbers... */
if 4 in possibleNumbers then write("4 is in the set!");
</PRE>
<P>Other previous languages have allowed for more powerful set semantics and 
syntax. A language called SETL (an acronym for SET Language) was created in the 
70s and offered sets as a first-class citizen. Unlike Pascal, when using sets in 
SETL you are not restricted to specifying the set's universe.</P>
<H2 class=dtH1><A name=datastructures20_6_topic3></A>Implementing an Efficient 
Set Data Structure</H2>
<P>In this section we'll look at creating a class that provides the 
functionality and features of a set. When creating such a data structure, one of 
the first things we need to decide is how to store the elements of the set. This 
decision can greatly affect the asymptotic efficiency of the operations 
performed on the set data structure. (Keep in mind that the operations we'll 
need to perform on the set data structure include: union, intersection, set 
difference, subset, and element of.)</P>
<P>To illustrate how storing the set's elements can affect the run time, imagine 
that we created a set class that used an underlying ArrayList to hold the 
elements of the set. If we had two sets, <I>S</I><SUB>1</SUB> and 
<I>S</I><SUB>2</SUB> that we wanted to union (where <I>S</I><SUB>1</SUB> had 
<I>m</I> elements and <I>S</I><SUB>2</SUB> had <I>n</I> elements), we'd have to 
perform the following steps: </P>
<OL type=1>
  <LI>Create a new set class, <I>T</I>, that holds the union of 
  <I>S</I><SUB>1</SUB> and <I>S</I><SUB>2</SUB>. 
  <LI>Iterate through the elements of <I>S</I><SUB>1</SUB>, adding it to 
  <I>T</I>. 
  <LI>Iterate through the elements of <I>S</I><SUB>2</SUB>. If the element does 
  not already exist in <I>T</I>, then add it to <I>T</I>. </LI></OL>
<P>How many steps would performing the union take? Step (2) would require 
<I>m</I> steps through <I>S</I><SUB>1</SUB>'s <I>m</I> elements. Step (3) would 
take <I>n</I> steps, and for each element in <I>S</I><SUB>2</SUB>, we'd have to 
determine if the element was in <I>T</I>. To determine if an element is in an 
unsorted List the entire List must be enumerated linerarly. So, for each of the 
<I>n</I> elements in <I>S</I><SUB>2</SUB> we might have to search through the 
<I>m</I> elements in <I>T</I>. This would lead to a quadratic running time for 
union of <I>O</I>(<I>m * n</I>). </P>
<P>The reason a union with a List takes quadratic time is because determining if 
an element exists within a set takes linear time. That is, to determine if an 
element exists in a set, the set's List must be exhaustively searched. If we 
could reduce the running time for the "element of" operation to a constant, we 
could improve the union's running time to a linear <I>O</I>(<I>m</I> + 
<I>n</I>). Recall from Part 2 of this article series that Hashtables and 
Dictionaries provides constant running time to determine if an item resides 
within the data structure. Hence, a Hashtable or Dictionary would be a better 
choice for storing the set's elements than a List.</P>
<P>If we require that the set's universe be known, we can implement an even more 
efficient set data structure using a bit array. Assume that the universe 
consists of elements <I>e</I><SUB>1</SUB>, <I>e</I><SUB>2</SUB>, ..., 
<I>e</I><SUB>k</SUB>. Then we can denote a set with a <I>k</I>-element bit 
array; if the <I>i</I>th bit is 1, then the element 
<I>e</I><SUB><SUB>i</SUB></SUB> is in the set; if, on the other hand, the 
<I>i</I>th bit is 0, then the element <I>e</I><SUB><SUB>i</SUB></SUB> is not in 
the set. Representing sets as a bit array not only provides tremendous space 
savings, but also enables efficient set operations, as these set-based 
operations can be performed using simple bit-wise instructions. For example, 
determining if element <I>e</I><SUB><SUB>i</SUB></SUB> exists in a set takes 
constant time because only the <I>i</I>th bit in the bit array needs to be 
checked. The union of two sets is simply the bit-wise OR of the sets' bit 
arrays; the intersection of two sets is the bit-wise AND of the sets' bit 
arrays. Set difference and subset can be reduced down to bit-wise operations as 
well.</P>
<BLOCKQUOTE class=dtBlock><B>Note&nbsp;&nbsp;&nbsp;</B>A bit array is a 
  compact array composed of 1s and 0s, typically implemented as an integer 
  array. Because an integer in the .NET Framework has 32 bits, a bit array can 
  store 32 bit values in one element of an integer array (rather than requiring 
  32 array elements).</BLOCKQUOTE>
<P>Bit-wise operations are ones that are performed on the individual bits of an 
integer. There are both binary bit-wise operators and unary bit-wise operators. 
The bit-wise AND and bit-wise OR operators are binary, taking in two bits each, 
and returning a single bit. Bit-wise AND returns 1 only if both inputs are 1, 
otherwise it returns 0. Bit-wise OR returns 0 only if both inputs are 0, 
otherwise it returns 1.</P>
<P>For a more in-depth look at bit-wise operations in C# be sure to read <A 
href="http://www.c-sharpcorner.com/Language/BitWiserOpsInCSCH001.asp">Bit-Wise 
Operators in C#</A>.</P>
<P>Let's look at how to implement a set class that uses C#'s bit-wise 
operations.</P>
<H3 class=dtH1>Creating the PascalSet Class</H3>
<P>Understand that to implement a set class that uses the efficient bit-wise 
operators the set's universe must be known. This is akin to the way Pascal uses 
sets, so in honor of the Pascal programming language I have decided to name this 
set class the <TT xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT> 
class. <TT xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT> restricts 
the universe to a range of integers or characters (just like the Pascal 
programming language). This range can be specified in the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT>'s constructor.</P><PRE class=code>public class PascalSet : ICloneable, ICollection, IEnumerable
{
   // Private member variables
   private int lowerBound, upperBound;
   private BitArray data;

   public PascalSet(int lowerBound, int upperBound)
   {
      // make sure lowerbound is less than or equal to upperbound
      if (lowerBound &gt; upperBound)
         throw new ArgumentException("The set's lower bound cannot be 
            greater than its upper bound.");

      this.lowerBound = lowerBound;
      this.upperBound = upperBound;

      // Create the BitArray
      data = new BitArray(upperBound - lowerBound + 1);
   }

   ...
}
</PRE>
<P>So, to create a <TT xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT> 
whose universe is the set of integers between -100 and 250, the following syntax 
could be used:</P><PRE class=code>PascalSet mySet = new PascalSet(-100, 250);
</PRE>
<H4 class=dtH1>Implementing the Set Operations</H4>
<P><TT xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT> implements the 
standard set operations—union, intersection, and set difference—as well as the 
standard relational operators—subset, proper subset, superset, and proper 
superset. The set operations union, intersection, and set difference, all return 
a new <TT xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT> instance, 
which contains the result of unioning, intersecting, or set differencing. The 
following code for the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Union(<I>PascalSet</I>)</TT> method 
illustrates this behavior:</P><PRE class=code>public virtual PascalSet Union(PascalSet s)
{
    if (!AreSimilar(s))
        throw new ArgumentException("Attempting to union two dissimilar 
           sets.  Union can only occur between two sets with the same universe.");

    // do a bit-wise OR to union together this.data and s.data
    PascalSet result = (PascalSet)Clone();
    result.data.Or(s.data);

    return result;
}

public static PascalSet operator +(PascalSet s, PascalSet t)
{
   return s.Union(t);
}
</PRE>
<P>The <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">AreSimilar(<I>PascalSet</I>)</TT> 
method determines if the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT> passed has the same 
lower and upper bounds as the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT> instance. Therefore, 
union (and intersection and set difference) can only be applied to two sets with 
the same universe. You could make a modification to the code here to have the 
returned <TT xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT>'s 
universe be the union of the two universe sets, thereby allowing sets with 
non-disjoint universes to be unioned. If the two <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT>s have the same 
universe, then a new <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT>—<TT 
xmlns:asp="http://msdn2.microsoft.com/asp">result</TT>—is created, which is an 
exact duplicate of the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT> instance whose <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">Union()</TT> method was called. This 
cloned <TT xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT>'s contents 
are modified using the bit-wise OR method, passing in the set whose contents are 
to be unioned. Notice that the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT> class also overloads 
the <TT xmlns:asp="http://msdn2.microsoft.com/asp">+</TT> operator for union 
(just like the Pascal programming language).</P>
<P>Similarly, the <B>PascalSet</B> class provides methods for intersection and 
set difference, along with the overloaded operators <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">*</TT> and <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">-</TT>, respectively. </P>
<H4 class=dtH1>Enumerating the PascalSet's Members</H4>
<P>Because sets are an <I>unordered</I> collection of elements, it would not 
make sense to have <TT xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT> 
implement <TT xmlns:asp="http://msdn2.microsoft.com/asp">IList</TT>, as 
collections that implement <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">IList</TT> imply that the list has 
some ordinal order. Because <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT> is a collection of 
elements, though, it makes sense to have it implement <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">ICollection</TT> and <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">IEnumerable</TT>. Because <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT> implements <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">IEnumerable</TT>, it needs to provide 
a <TT xmlns:asp="http://msdn2.microsoft.com/asp">GetEnumerator()</TT> method 
that returns an <TT xmlns:asp="http://msdn2.microsoft.com/asp">IEnumerator</TT> 
instance allowing a developer to iterate through the set's elements. This method 
simply iterates through the set's underlying <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">BitArray</TT>, returning the 
corresponding value for each bit with a value of 1.</P><PRE class=code>public IEnumerator GetEnumerator()
{
    int totalElements = Count;
    int itemsReturned = 0;
    for (int i = 0; i &lt; this.data.Length; i++)
    {
        if (itemsReturned &gt;= totalElements)
            break;
        else if (this.data.Get(i))
            yield return i + this.lowerBound;
    }
}
</PRE>
<P>To enumerate the PascalSet, you can simply use a <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">foreach</TT> statement. The following 
code snippet demonstrates creating two PascalSet instances and then enumerating 
the elements of their union:</P><PRE class=code>PascalSet a = new PascalSet(0, 255, new int[] {1, 2, 4, 8});
PascalSet b = new PascalSet(0, 255, new int[] { 3, 4, 5, 6 });

foreach(int i in a + b)
   MessageBox.Show(i);
</PRE>
<P>This code would display seven messageboxes, one after the other, displaying 
values 1, 2, 3, 4, 5, 6, and 8.</P>
<P>The complete code for the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT> class is included as a 
download with this article. Along with the class, there is an interactive 
Windows Forms testing application, <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">SetTester</TT>, from which you can 
create a <TT xmlns:asp="http://msdn2.microsoft.com/asp">PascalSet</TT> instance 
and perform various set operations, viewing the resulting set. </P>
<H2 class=dtH1><A name=datastructures20_6_topic4></A>Maintaining a Collection of 
Disjoint Sets</H2>
<P>Next time you do a search at Google notice that with each result there's a 
link titled "Similar Pages." If you click this link, Google displays a list of 
URLs that are related to the item whose "Similar Pages" link you clicked. While 
I don't know how Google particularly determines how pages are related, one 
approach would be the following: </P>
<UL type=disc>
  <LI>Let <I>x</I> be the Web page we are interested in finding related pages 
  for. 
  <LI>Let <I>S</I><SUB>1</SUB> be the set of Web pages that <I>x</I> links to. 
  <LI>Let <I>S</I><SUB>2</SUB> be the set of Web pages that the Web pages in 
  <I>S</I><SUB>1</SUB> link to. 
  <LI>Let <I>S</I><SUB>3</SUB> be the set of Web pages that the Web pages in 
  <I>S</I><SUB>2</SUB> link to. 
  <LI>... 
  <LI>Let <I>S</I><SUB>k</SUB> be the set of Web pages that the Web pages in 
  <I>S</I><SUB>k-1</SUB> link to. </LI></UL>
<P>All of the Web pages in <I>S</I><SUB>1</SUB>, <I>S</I><SUB>1</SUB>, up to 
<I>S</I><SUB>k</SUB> are the related pages for <I>x</I>. Rather than compute the 
related Web pages on demand, we might opt to create the set of related pages for 
<I>all</I> Web pages once, and to store this relation in a database or some 
other permanent store. Then, when a user clicks on the "Similar Pages" link for 
a search term, we simply query the display to get the links related to this 
page.</P>
<P>Google has some sort of database with all of the Web pages it knows about. 
Each of these Web pages has a set of links. We can compute the set of related 
Web pages using the following algorithm: </P>
<OL type=1>
  <LI>For each Web page in the database create a set, placing the single Web 
  page in the set. After this step completes, if we have <I>n</I> Web pages in 
  the database, we'll have <I>n</I> one-element sets. 
  <LI>For a Web page <I>x</I> in the database, find all of those Web pages it 
  directly links to. Call these linked-to pages <I>S</I>. For each element 
  <I>p</I> in <I>S</I>, union the set containing <I>p</I> with <I>x</I>'s set. 
  <LI>Repeat step 2 for all Web pages in the database. </LI></OL>
<P>After step 3 completes, the Web pages in the database will be partitioned out 
into related groups. To view a graphical representation of this algorithm in 
action, consult Figure 1.</P>
<P class=fig><IMG alt="" 
src="Part 6 Efficiently Representing Sets.files/IC85014.gif" border=0></P>
<P class=label><B>Figure 1. A graphical representation of an algorithm for 
grouping linked web pages.</B></P>
<P>Examining Figure 1, notice that in the end, there are three related 
partitions: </P>
<UL type=disc>
  <LI>w0 
  <LI>w1, w2, w3, and w4 
  <LI>w5 and w6 </LI></UL>
<P>So, when a user clicks the "Similar Pages" link for w2, they would see links 
to w1, w3, and w4; clicking the "Similar Pages" link for w6 would show only a 
link to w5.</P>
<P>Notice that with this particular problem only one set operation is being 
performed—union. Furthermore, all of the Web pages fall into <I>disjoint 
sets</I>. Given an arbitrary number of sets, these sets are said to be 
<I>disjoint</I> if they share no elements in common. {1,2,3} and {4,5,6} are 
disjoint, for example, while {1,2,3} and {2,4,6} are not, because they share the 
common element 2. In all stages shown in Figure 1, each of the sets containing 
Web pages are disjoint. That is, it's never the case that one Web page exists in 
more than one set at a time. </P>
<P>When working with disjoint sets in this manner, we often need to know what 
particular disjoint set a given element belongs to. To identify each set we 
arbitrarily pick a <I>representative</I>. A representative is an element from 
the disjoint set that uniquely identifies that entire disjoint set. With the 
notion of a representative, I can determine of two given elements are in the 
same set by checking to see if they have the same representative.</P>
<P>A disjoint set data structure needs to provide two methods: </P>
<UL type=disc>
  <LI><B>GetRepresentative(element):</B> this method accepts an element as an 
  input parameter and returns the element's representative element. 
  <LI><B>Union(element, element):</B> this method takes in two elements. If the 
  elements are from the same disjoint set, then <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">Union()</TT> does nothing. If, 
  however, the two elements are from different disjoint sets, then <TT 
  xmlns:asp="http://msdn2.microsoft.com/asp">Union()</TT> combines the two 
  disjoint sets into one set. </LI></UL>
<P>The challenge that faces us now is how to efficiently maintain a number of 
disjoint sets, where these disjoint sets are often merged from two sets into 
one. There are two basic data structures that can be used to tackle this 
problem—one uses a series of linked lists, the other collection of trees.</P>
<H3 class=dtH1>Maintaining Disjoint Sets with Linked Lists</H3>
<P>In Part 4 of this article series we took a moment to look at a Quick Primer 
on Linked Lists. Recall that linked lists are a set of nodes that typically have 
a single reference to their next neighbor. Figure 2 shows a linked list with 
four elements.</P>
<P class=fig><IMG alt="" 
src="Part 6 Efficiently Representing Sets.files/IC14102.gif" border=0></P>
<P class=label><B>Figure 2. A linked list with four elements</B></P>
<P>For the disjoint set data structure, a set is represented using a modified 
linked list. Rather than just having a reference to its neighbor, each node in 
the disjoint set linked list has a reference to the set's representative. As 
Figure 3 illustrates, <I>all</I> nodes in the linked list point to the 
<I>same</I> node as their representative, which is, by convention, the head of 
the linked list. (Figure 3 shows the linked list representation of the disjoint 
sets from the final stage of the algorithm dissected in Figure 1. Notice that 
for each disjoint set there exists a linked list, and that the nodes of the 
linked list contain the elements of that particular disjoint set.)</P>
<P class=fig><IMG alt="" 
src="Part 6 Efficiently Representing Sets.files/IC170257.gif" border=0></P>
<P class=label><B>Figure 3. A linked list representation of the disjoint sets 
from the final stage of the algorithm dissected in Figure 1.</B></P>
<P>Because each element in a set has a direct reference back to the set's 
representative, the <TT 
xmlns:asp="http://msdn2.microsoft.com/asp">GetRepresentative(<I>element</I>)</TT> 
method takes constant time. (To understand why, consider that regardless of how 
many elements a set has, it will always take one operation to find a given 
element's representative, because it involves just checking the element's 
representative reference.)</P>
<P>Using the linked list approach, combining two disjoint sets into one involves 
adding one linked list to the end of another, and updating the representative 
reference in each of the appended nodes. The process of joining two disjoint 
sets is depicted in Figure 4.</P>
<P class=fig><IMG alt="" 
src="Part 6 Efficiently Representing Sets.files/IC59217.gif" border=0></P>
<P class=label><B>Figure 4. The process of joining two disjoint sets</B></P>
<P>When unioning together two disjoint sets, the correctness of the algorithm is 
not affected by which of the two sets is appended to the other. However, the 
running time can be. Imagine that our union algorithm randomly chose one of the 
two linked lists to be appended to the other. By a stroke of bad luck, imagine 
that we always chose the longer of the two linked lists to append. This can 
negatively impact the running time of the union operation since we have to 
enumerate all of the nodes in the appended linked list to update their 
representative reference. That is, imagine we make <I>n</I> disjoint sets, 
<I>S</I><SUB>1</SUB> to <I>S</I><SUB>n</SUB>. Each set would have one element. 
We could then do <I>n </I>- 1 unions, joining all <I>n</I> sets into one big set 
with <I>n</I> elements. Imagine the first union joined <I>S</I><SUB>1</SUB> and 
<I>S</I><SUB>2</SUB>, having <I>S</I><SUB>1</SUB> be the representative for this 
two element unioned set. Since <I>S</I><SUB>2</SUB> only has one element, only 
one representative reference would need to be updated. Now, imagine 
<I>S</I><SUB>1</SUB>—which has two elements—is unioned with 
<I>S</I><SUB>3</SUB>, and <I>S</I><SUB>3</SUB> is made the representative. This 
time two representative references—<I>S</I><SUB>1</SUB>'s and 
<I>S</I><SUB>2</SUB>'s—will need to be updated. Similarly, when joining 
<I>S</I><SUB>3</SUB> with <I>S</I><SUB>4</SUB>, if <I>S</I><SUB>4</SUB> is made 
the representative of the new set, three representative references will need to 
be updated (<I>S</I><SUB>1</SUB>, <I>S</I><SUB>2</SUB>, and 
<I>S</I><SUB>3</SUB>). In the (<I>n</I>-1)th union, <I>n</I>-2 representative 
references will need to be updated.</P>
<P>Summing up the number of operations that must be done for each step, we find 
that the entire sequence of steps—<I>n</I> make set operations and <I>n</I>-1 
unions—takes quadratic time—<I>O</I>(<I>n</I><SUP>2</SUP>). </P>
<P>This worst-case running time can transpire because it is possible that union 
will choose the longer set to append to the shorter set. Appending the longer 
set requires that more nodes' representative references need to be updated. A 
better approach is to keep track of the size of each set, and then, when joining 
two sets, to append the smaller of the two linked lists. The running time when 
using this improved approach is reduced to <I>O</I>(n log<SUB>2</SUB> <I>n</I>). 
A thorough time analysis is a bit beyond the scope of this article, and is 
omitted for brevity. Refer to the readings in the References section for a 
formal proof of the time analysis.</P>
<P>To appreciate the improvement of <I>O</I>(n log<SUB>2</SUB> <I>n</I>) from 
<I>O</I>(<I>n</I><SUP>2</SUP>), observe Figure 5, which shows the growth rate of 
<I>n</I><SUP>2</SUP> in blue, and the grown rate of n log<SUB>2</SUB> <I>n</I> 
in pink. For small values of <I>n</I>, these two are comparable, but as <I>n</I> 
exceeds 32, the n log<SUB>2</SUB> <I>n</I> grows much slower than 
<I>n</I><SUP>2</SUP>. For example, performing 64 unions would require over 4,000 
operations using the naive linked list implementation, while it would take only 
384 operations for the optimized linked list implementation. These differences 
become even more profound as <I>n</I> gets larger.</P>
<P class=fig><IMG alt="" 
src="Part 6 Efficiently Representing Sets.files/IC68564.gif" border=0></P>
<P class=label><B>Figure 5. Growth rates of n</B><SUP>2</SUP><B> and n 
log</B><SUB>2</SUB></P>
<H3 class=dtH1>Maintaining Disjoint Sets with a Forest</H3>
<P>Disjoint sets can also be maintained using a <I>forest</I>. A forest is a set 
of trees (get it? ). Recall that with the linked list implementation, the set's 
representative was the head of the list. With the forest implementation, each 
set is implemented as a tree, and the set's representative is the root of the 
tree. (If you are unfamiliar with what trees are, consider reading <A 
href="http://msdn.microsoft.com/en-US/library/ms379572(v=VS.80).aspx">Part 3</A> 
of this article series, where we discussed trees, binary trees, and binary 
search trees.)</P>
<P>With the linked list approach, given an element, finding its set's 
representative was fast because each node had a direct reference to its 
representative. However, with the linked list approach unioning took longer 
because it involved appending one linked list to another, which required that 
the appended nodes' representative references be updated. The forest approach 
aims at making unions fast, at the expense finding a set's representative given 
an element in the set.</P>
<P>The forest approach implements each disjoint set as a tree, with the root as 
the representative. To union together two sets, one tree is appended as a child 
of the other. Figure 6 illustrates this concept graphically.</P>
<P class=fig><IMG alt="" 
src="Part 6 Efficiently Representing Sets.files/IC164074.gif" border=0></P>
<P class=label><B>Figure 6. The union of two sets</B></P>
<P>To union two sets together requires constant time, as only one node needs to 
have its representative reference updated. (In Figure 6, to union together the 
w1 and w3 sets, all we had to do was have w3 update its reference to w1—nodes w4 
and w5 didn't need any modification.)</P>
<P>Compared to the linked list implementation, the forest approach has improved 
the time required for unioning two disjoint sets, but has worsened the time for 
finding the representative for a set. The only way we can determine a set's 
representative, given an element, is to walk up the set's tree until we find the 
root. Imagine that we wanted to find the representative for w5 (after sets w1 
and w3 had been unioned). We'd walk up the tree until we reached the root—first 
to w3, and then to w1. Hence, finding the set's representative takes time 
relative to the depth of the tree, and not constant time as it does with the 
linked list representation.</P>
<P>The forest approach offers two optimizations that, when both employed, yield 
a linear running time for performing <I>n</I> disjoint set operations, meaning 
that each single operation has an average constant running time. These two 
optimizations are called union by rank and path compression. What we are trying 
to avoid with these two optimizations is having a sequence of unions generate a 
tall, skinny tree. As discussed in Part 3 of this article series, the ratio of a 
tree's height to breadth typically impacts its running time. Ideally, a tree is 
fanned out as much as possible, rather than being tall and narrow.</P>
<H4 class=dtH1>The Union by Rank Optimization</H4>
<P>Union by rank is akin to the linked list's optimization of appending the 
shorter list to the longer one. Specifically, union by rank maintains a rank for 
each sets' root, which provides an upperbound on the height of the tree. When 
unioning two sets, the set with the smaller rank is appended as a child of the 
root with the larger rank. Union by rank helps ensure that our trees will be 
broad. However, even with union by rank we might still end up with tall, albeit 
wide, trees. Figure 7 shows a picture of a tree that might be formed by a series 
of unions that adhere only to the union by rank optimization. The problem is 
that leaf nodes on the right hand side still must perform a number of operations 
to find their set's representative.</P>
<P class=fig><IMG alt="" 
src="Part 6 Efficiently Representing Sets.files/IC18343.gif" border=0></P>
<P class=label><B>Figure 7. A tree that might be formed by a series of unions 
that adhere only to the union by rank optimization</B></P>
<BLOCKQUOTE class=dtBlock><B>Note&nbsp;&nbsp;&nbsp;</B>The forest approach, 
  when implementing just the union by rank optimization, has the same running 
  time as the optimized link list implementation.</BLOCKQUOTE>
<H4 class=dtH1>The Path Compression Optimization</H4>
<P>Because a tall tree makes finding a set's representative expensive, ideally 
we'd like our trees to be broad and flat. The path compression optimization 
works to flatten out a tree. As we discussed earlier, whenever an element is 
queries for its set's representative, the algorithm walk up the tree to the 
root. The way the path compression optimization works is in this algorithm, the 
nodes that are visited in the walk up to the root have their parent reference 
updated to the root.</P>
<P>To understand how this flattening works, consider the tree in Figure 7. Now, 
imagine that we need to find the set representative for w13. The algorithm will 
start at w13, walk up to w12, then to w8, and finally to w1, returning w1 as the 
representative. Using path compression, this algorithm will also have the side 
effect of updating w13 and w12's parents to the root—w1. Figure 8 shows a 
screenshot of the tree after this path compression has occurred.</P>
<P class=fig><IMG alt="" 
src="Part 6 Efficiently Representing Sets.files/IC158201.gif" border=0></P>
<P class=label><B>Figure 8. A tree after path compression</B></P>
<P>Path compression pays a slight overhead the first time when finding a 
representative, but benefits future representative lookups. That is, after this 
path compression has occurred, finding the set representative for w13 takes one 
step, because w13 is a child of the root. In Figure 7, prior to path 
compression, finding the representative for w13 would have taken three steps. 
The idea here is that you pay for the improvement once, and then benefit from 
the improvement each time the check is performed in the future.</P>
<P>When employing both the union by rank and path compression algorithms, the 
time is takes to perform <I>n</I> operations on disjoint sets is linear. That 
is, the forest approach, utilizing both optimizations, has a running time of 
<I>O</I>(<I>n</I>). You'll have to take my word on this, as the formal proof for 
the time complexity is quite lengthy and involved, and could easily fill several 
printed pages. If you are interested, though, in reading this multi-page time 
analysis, refer to the "Introduction to Algorithms" text listed in the 
references.</P>
<H3 class=dtH1>References</H3>
<UL type=disc>
  <LI>Alur, Rajeev. "Disjoint Sets." Available online at: <A 
  href="http://www.cis.upenn.edu/~cse220/h29.pdf">http://www.cis.upenn.edu/~cse220/h29.pdf</A>. 

  <LI>Cormen, Thomas H., Charles E. Leiserson, and Ronald L. Rivest. 
  "Introduction to Algorithms." MIT Press. 1990. 
  <LI>Devroye, Luc. "Disjoint Set Structures." Available online at: <A 
  href="http://www.cs.mcgill.ca/~cs251/OldCourses/1997/topic24/">http://www.cs.mcgill.ca/~cs251/OldCourses/1997/topic24/</A>. 
  </LI></UL>
<P><B>Scott Mitchell</B>, author of six books and founder of 4GuysFromRolla.com, 
has been working with Microsoft Web technologies because January 1998. Scott 
works as an independent consultant, trainer, and writer, and holds a Masters 
degree in Computer Science from the University of California – San Diego. He can 
be reached at <A 
href="mailto:mitchell@4guysfromrolla.com">mitchell@4guysfromrolla.com</A>, or 
via his blog at <A 
href="http://scottonwriting.net/">http://scottonwriting.net/</A>.</P>
<DIV class=footer><BR>
<P></P>
<P><A href="http://msdn.microsoft.com/en-US/library/ms369863(v=VS.80).aspx">© 
Microsoft Corporation. All rights 
reserved.</A></P></DIV></DIV></DIV></DIV></DIV></DIV>
<DIV class=footer>
<DIV class="footerContainer cl_footer_slice" id=footer>
<DIV class=footerLogoContainer>
<DIV class=footerContent>
<DIV class=copyright>© 2011 Microsoft. All rights reserved.</DIV>
<DIV class="footerLogo cl_footer_logo"></DIV><A 
href="http://msdn.microsoft.com/cc300389.aspx">Terms of Use</A><SPAN class=pipe> 
| </SPAN><A 
href="http://www.microsoft.com/library/toolbar/3.0/trademarks/en-us.mspx">Trademarks</A><SPAN 
class=pipe> | </SPAN><A 
href="http://www.microsoft.com/info/privacy.mspx">Privacy Statement</A> <SPAN 
class=pipe>| </SPAN><A class=FeedbackLink title=Feedback 
onclick=javascript:ShowFeedbackDialog(); 
href="http://msdn.microsoft.com/en-US/library/ms379575(v=VS.80).aspx#footerLink">Feedback 
<SPAN class="FeedbackButton clip20x21" id=FeedbackButton><IMG 
class=cl_footer_feedback_icon alt=Feedback 
src="Part 6 Efficiently Representing Sets.files/a19e30a4020fe81d2b1209058013a360.png"> 
</SPAN></A>
<DIV class=FeedbackContainer id=FeedbackContainer><FORM 
action="/en-US/library/feedback/add/ms379575(v=VS.80).aspx" method="post">
<DIV class=FeedbackTitleContainer>
<DIV class=FeedbackTitle>Feedback</DIV>
<DIV class=FeedbackCancel><A 
onclick="document.getElementById('FeedbackContainer').style.display = 'none';" 
href="javascript:;">x</A> </DIV></DIV>
<DIV class=FeedbackData>
<DIV class=FeedbackInfoText>Tell us about your experience... </DIV>
<DIV class=QuestionText>Did the page load quickly? </DIV>
<DIV class=AnswerText><SPAN>Yes<SPAN> <INPUT id=searchBox type=radio value=1 
name=searchBox></SPAN></SPAN> <SPAN>No<SPAN> <INPUT id=searchBox type=radio 
value=0 name=searchBox></SPAN></SPAN> </DIV>
<DIV class=QuestionText>Do you like the page design? </DIV>
<DIV class=AnswerText><SPAN>Yes<SPAN> <INPUT id=tabbedCode type=radio value=1 
name=tabbedCode></SPAN></SPAN> <SPAN>No<SPAN> <INPUT id=tabbedCode type=radio 
value=0 name=tabbedCode></SPAN></SPAN> </DIV>
<DIV class=QuestionText>How useful is this topic? </DIV>
<DIV class="FeedbackGraphicHolder clip269x23"><IMG 
class="cl_online_scale FeedbackSiderGraphic" alt="" 
src="Part 6 Efficiently Representing Sets.files/a19e30a4020fe81d2b1209058013a360.png"> 
</DIV>
<DIV class=RadioButtonHolder>
<DIV class=RateRadioOne><INPUT id=topicUseful title="Really disliked it" 
type=radio value=1 name=topicUseful> </DIV>
<DIV class=RateRadio><INPUT id=topicUseful title="Disliked it" type=radio 
value=2 name=topicUseful> </DIV>
<DIV class=RateRadio><INPUT id=topicUseful title=OK type=radio value=3 
name=topicUseful> </DIV>
<DIV class=RateRadio><INPUT id=topicUseful title=Good type=radio value=4 
name=topicUseful> </DIV>
<DIV class=RateRadioLast><INPUT id=topicUseful title="Really Good" type=radio 
value=5 name=topicUseful> </DIV></DIV>
<DIV class=QuestionText>Tell us more </DIV>
<DIV class=FeedbackTextAreaContainer><TEXTAREA class=FeedbackTextArea onkeydown="LimitText(this, 4000);" onblur="document.onkeydown = Presskey;" onkeyup="LimitText(this, 4000);" onfocus="document.onkeydown = '';" name=feedbackText rows=5 cols=25></TEXTAREA> 
<TEXTAREA id=feedbackDescription onkeydown="LimitText(this, 4000);" onkeyup="LimitText(this, 4000);" style="DISPLAY: none" name=feedbackDescription rows=10 cols=25>Enter description here.</TEXTAREA> 
<INPUT id=feedbackPriority type=hidden name=feedbackPriority> <INPUT 
id=feedbackSourceUrl type=hidden name=feedbackSourceUrl> <INPUT id=ClientIP 
type=hidden name=ClientIP> <INPUT id=ClientOS type=hidden name=ClientOS> <INPUT 
id=ClientBrowser type=hidden name=ClientBrowser> <INPUT id=ClientTime 
type=hidden name=ClientTime> <INPUT id=ClientTimeZone type=hidden 
name=ClientTimeZone> </DIV>
<DIV><INPUT class=FeedbackSubmit onclick="document.getElementById('feedbackDescription').value='';document.getElementById('feedBackVersion').value = '-1';" type=submit value=Send> 
</DIV></DIV><INPUT id=returnUrl type=hidden 
value=http://msdn.microsoft.com/en-US/library/ms379575(v=VS.80).aspx 
name=returnUrl> <INPUT id=feedBackVersion type=hidden value=1 
name=feedBackVersion> </FORM></DIV></DIV></DIV></DIV></DIV>
<DIV class=MetricsContainer>
<DIV class=WebtrendsContainer>
<SCRIPT language=javascript type=text/javascript>
//<![CDATA[
  var literalNormalizedUrl = '/en-us/library/ms379575(d=lightweight,l=en-us,v=VS.80).aspx';
  var wt_nvr_ru = 'WT_NVR_RU';
  var wt_fpcdom = '.microsoft.com';
  var wt_domlist = 'msdn.microsoft.com';
  var wt_pathlist = '';
  var wt_paramlist = 'DCSext.mtps_devcenter';
  var wt_siteid = 'MSDN';
  var gDomain = 'm.webtrends.com';
  var gDcsId = 'dcsmgru7m99k7mqmgrhudo0k8_8c6m';
  var gFpc = 'WT_FPC';
  if (document.cookie.indexOf(gFpc + "=") == -1) {
    document.write("<scr" + "ipt type='text/javascript' src='" + "http" + (window.location.protocol.indexOf('https:') == 0 ? 's' : '') + "://" + gDomain + "/" + gDcsId + "/wtid.js" + "'><\\/scr" + "ipt>");
  }
  var detectedLocale = 'en-US';
  var wtsp = 'msdnlib_devtools_lang';
  var gTrackEvents = '0';
/*]]>*/
</SCRIPT>
<NOSCRIPT>
<DIV><IMG id=Img1 height=1 alt=DCSIMG 
src="Part 6 Efficiently Representing Sets.files/njs.gif" 
width=1></DIV></NOSCRIPT></DIV>
<DIV class=OmnitureContainer>
<SCRIPT type=text/javascript>
  var omni_guid = '8df0ae03-e2a8-456a-b054-5c76c7fbcc10'; 
</SCRIPT>
<NOSCRIPT><A title="Web Analytics" href="http://www.omniture.com/"><IMG height=1 
alt="" src="Part 6 Efficiently Representing Sets.files/0.gif" width=1 
border=0></A> </NOSCRIPT></DIV></DIV>
<SCRIPT language=javascript 
src="Part 6 Efficiently Representing Sets.files/broker.js" 
type=text/javascript></SCRIPT>

<SCRIPT 
src="Part 6 Efficiently Representing Sets.files/c2b4b2079ab4502f4c4e4b7eddfdc341.js" 
type=text/javascript xmlns="http://www.w3.org/1999/xhtml"></SCRIPT>
</BODY></HTML>
